/*
 * ParaStation
 *
 * Copyright (C) 2003-2004 ParTec AG, Karlsruhe
 * Copyright (C) 2005-2017 ParTec Cluster Competence Center GmbH, Munich
 * Copyright (C) 2021-2023 ParTec AG, Munich
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined in the file LICENSE.QPL included in the packaging of this
 * file.
 */
/**
 * @file
 * Helper functions in order to setup and handle partitions.
 */
#ifndef __PSIDPARTITION_H
#define __PSIDPARTITION_H

#include <stdbool.h>
#include <stdint.h>

#include "psprotocol.h"
#include "psnodes.h"
#include "pstask.h"
#include "pspartition.h"
#include "psreservation.h"

/**
 * @brief Initialize partition stuff
 *
 * Initialize the partition handling framework. This registers
 * the necessary message handlers.
 *
 * @return No return value.
 */
void initPartition(void);

/**
 * @brief Send a PSP_DD_GETTASKS message
 *
 * Send a PSP_DD_GETTASKS message to the node with ParaStation ID @a
 * node. This message on the one hand requests a list of all running
 * tasks on the receiving node, on the other hand a list of all
 * pending partition request on the receiving node.
 *
 * Thus, this message will be answered by one or more
 * PSP_DD_PROVIDETASK messages and zero or more PSP_DD_GETPART
 * messages.
 *
 * Usually this message is generated by a new master node in order to
 * get an overview on the cluster status.
 *
 * @param node The node requested to send a list of active tasks
 * and pending partition requests.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_GETTASKS message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_GETTASKS(PSnodes_ID_t node);

/**
 * @brief Send a PSP_DD_TASKDEAD message
 *
 * Send a PSP_DD_TASKDEAD message to @a dest. If @a dest is the daemon
 * on the current master node, it informs this master daemon on the
 * exit of the root process with task ID @a tid and thus allows to
 * free the corresponding partition.
 *
 * If @a dest is a different task ID it shall address a psidlogger or
 * step forwarder and tell about the release of a sister partition.
 *
 * @param dest Destination task ID
 *
 * @param tid Task ID of the (sister-)partition to release
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKDEAD message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKDEAD(PStask_ID_t dest, PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_TASKSUSPEND message
 *
 * Send a PSP_DD_TASKSUSPEND message to the current master node. This
 * message informs the master node on the suspension of the root
 * process with task ID @a tid and thus probably allows to temporarily
 * free the corresponding partition.
 *
 * @param tid The task ID of the root process that was suspended.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKSUSPEND message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKSUSPEND(PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_TASKRESUME message.
 *
 * Send a PSP_DD_TASKRESUME message to the current master node. This
 * message informs the master node on the continuation of the root
 * process with task ID @a tid and thus probably to reallocate the
 * corresponding temporarily freed partition.
 *
 * @param tid The task ID of the root process that continues to run.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKRESUME message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKRESUME(PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_CANCELPART message.
 *
 * Send a PSP_DD_CANCELPART message to the current master node.  This
 * message informs the master node on the exit of the root process
 * with task ID @a tid and thus allows to cancel the corresponding
 * partition request.
 *
 * @param tid The task ID of the root process that exited.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_CANCELPART message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_CANCELPART(PStask_ID_t tid);

/**
 * @brief Initialized partition handler.
 *
 * Initialize the partition handler machinery. This includes allocating
 * memory used to store centralized information on the allocated
 * partitions and pending partition requests.
 *
 * Usually this function is called upon detection that the local
 * daemon has to act as a master within the cluster.
 *
 * @return No return value.
 */
void initPartHandler(void);

/**
 * @brief Remove requests.
 *
 * Remove all requests originating from node @a node from the queue of
 * pending processes and from the queue of running processes.
 *
 * Within this function, the partition requests are actually not
 * removed from the queue, but only marked to get deleted within the
 * next round of handlePartRequests(). This is necessary to make this
 * function robust enough the get used from within a RDP callback.
 *
 * @param node The node whose request are going to be cleaned up.
 *
 * @return No return value.
 */
void cleanupRequests(PSnodes_ID_t node);

/**
 * @brief Shutdown partition handler.
 *
 * Shut down the partition handler machinery. This includes
 * freeing memory used to store centralized information on the
 * allocated partitions and pending partition requests as allocated
 * within @ref initPartHandler().
 *
 * Usually this function is called upon detection that the local
 * daemon is freed from the burden of acting as the master within the
 * cluster.
 *
 * @return No return value.
 */
void exitPartHandler(void);

/**
 * @brief Number of assigned SW-threads.
 *
 * Return the number of SW-threads assigned to node @a node.
 *
 * @param node The node to request.
 *
 * @return On success, the number of SW-threads assigned to the
 * requested node is returned, or 0, if an error occurred. Be aware of
 * the fact, that an error cannot be distinguished from an empty node.
 */
unsigned short getAssignedThreads(PSnodes_ID_t node);

/**
 * @brief The nodes exclusive flag.
 *
 * Return the flag marking node @a node to be used by its current job
 * exclusively.
 *
 * @param node The node to request.
 *
 * @return On success, the nodes exclusive flag is returned, i.e. the
 * flag marking the node to be used by its current job exclusively. Or
 * false, if an error occurred. Be aware of the fact, that an error
 * cannot be distinguished from a node not used exclusively.
 */
bool getIsExclusive(PSnodes_ID_t node);


/**
 * @brief Send list of requests.
 *
 * Send a list of partition-requests registered within the master
 * daemon. Depending on the flags set within @a opt, only pending,
 * running or suspended requests might be send to the @a requester.
 *
 * If @a ref PART_LIST_NODES is set in @a opt, also a list of the
 * processor slots allocated to the request is sent.
 *
 * @param requester Task ID of process waiting for answer.
 *
 * @param opt Option flags marking which type of requests to send and
 * format of answer (with/without list of slots).
 *
 * @return No return value.
 */
void sendRequestLists(PStask_ID_t requester, PSpart_list_t opt);

/**
 * @brief Register partition
 *
 * Register or extend an existing partition as given within the array
 * of HW-threads @a thrds of size @a num to the task-structure @a
 * task. @ref thrds is expected to hold HW-threads that the task is
 * allowed to use as part of its partition. For that, the @ref
 * partition section in @a task will be created out or extended by the
 * the passed HW-threads and registered to the master psid.
 *
 * This mechanism shall be used in order to inform the master daemon
 * on partitioning decisions taken by some external resource
 * manager. Thus, it will be called primarily from inside psmom or
 * psslurm.
 *
 * @param task Task to register or modify
 *
 * @param threads Array of HW-threads forming or extending the partition
 *
 * @param num Size of @a threads
 *
 * @return No return value
 */
void PSIDpart_register(PStask_t *task, PSpart_HWThread_t *threads, uint32_t num);

/**
 * @brief Send reservation's nodelist
 *
 * Send the nodelist of the reservation with ID @a resID belonging to
 * the task @a task to the destination stored in @a msg. The message
 * @a msg furthermore contains the sender and the message type used to
 * send one or more messages containing the list of
 * nodes. Additionally @a msg's buffer might contain some preset
 * content. Thus, its internally stored length (in the .len field) has
 * to correctly represent the messages preset content.
 *
 * In order to send the list of nodes, it is split into chunks. Each
 * chunk is copied into the message and send separately to its
 * destination.
 *
 * @param resID The ID of the reservation to investigate.
 *
 * @param task The task the reservation belongs to.
 *
 * @param msg The message buffer used to send the reservations node-list.
 *
 * @return No return value
 */
void PSIDpart_sendResNodes(PSrsrvtn_ID_t resID, PStask_t *task,
			   DDTypedBufferMsg_t *msg);

/**
 * @brief Cleanup reservations
 *
 * Cleanup all reservations associated to the task @a task. For this,
 * all HW-threads allocated in reservations are marked as unused again
 * in the corresponding partition.
 *
 * @param task Task structure holding the reservations to cleanup
 *
 * @return No return value
 */
void PSIDpart_cleanupRes(PStask_t *task);

/**
 * @brief Cleanup reserved slots
 *
 * Cleanup all slots associated to the task @a task. These slots got
 * associated by PSP_CD_GETSLOTS messages sent by the task requesting
 * slots from a reservation in order to use them for spawning
 * processes later on.
 *
 * This function will create corresponding PSP_DD_CHILDRESREL messages
 * for each of the slots stored in the task's @ref spawnNodes
 * attribute not yet used for spawning.
 *
 * @param task Task structure holding the slots to cleanup
 *
 * @return No return value
 */
void PSIDpart_cleanupSlots(PStask_t *task);

/**
 * @brief Suspend reserved slots
 *
 * Suspend the HW-threads in the first @a nSlots slots in the array @a
 * slot from the task @a task. By this means the corresponding
 * resources become available again and might be used by different
 * reservations while they are suspended. In order to end the
 * suspension @ref PSIDpart_contSlts() might be used.
 *
 * This function is aware of resource delegation and might change the
 * corresponding resources within the delegate.
 *
 * @param slot Array of slots to be suspended
 *
 * @param nSlots Number of slots to be considered within @a slot
 *
 * @param task Task structure owning the HW-threads to be suspended.
 *
 * @return The number of HW-threads actually suspended
 */
int PSIDpart_suspSlts(PSpart_slot_t *slot, unsigned int nSlots, PStask_t *task);

/**
 * @brief Re-assign reserved slots
 *
 * Re-assign the HW-threads in the first @a nSlots slots in the array
 * @a slot to the task @a task. By this means the corresponding
 * resources become unavailable again and can no longer be used to
 * create additional reservations. This function is used to end the
 * suspension created by @ref PSIDpart_suspSlts().
 *
 * This function is aware of resource delegation and might change the
 * corresponding resources within the delegate.
 *
 * @param slot Array of slots to be re-assigned
 *
 * @param nSlots Number of slots to be considered within @a slot
 *
 * @param task Task structure owning the HW-threads to be re-assigned.
 *
 * @return The number of HW-threads actually re-assigned
 */
int PSIDpart_contSlts(PSpart_slot_t *slot, unsigned int nSlots, PStask_t *task);

/**
 * @brief Extend reservation
 *
 * @attention This mechanism is outdated. The modern realization requires
 * sister partitions in order to provide all information to
 * psidsession. Those sister partitions are generated and distributed
 * on the fly in the case of psslurm as long as enough resources are
 * available within the allocation.
 *
 * Extend the reservation identified by the ID @a resID and associated
 * to the task with ID @a tid by @a got slots given in the array @a
 * slots. The latter is expected to have at least @a got entries.
 *
 * This function expects the slots to be according to the requirements
 * stated in the corresponding reservation requests.
 *
 * @param tid The task ID the reservation is associated with
 *
 * @param resID The ID of the reservation to be extended
 *
 * @param got The number of slots to be added to the given
 * reservation. If this is 0, we assumed no resources are available
 * and the originating request for a reservation might fail.
 *
 * @param slots Array holding the slots to be added to the
 * reservation. At least @a got entries are expected. Each entry shall
 * be according to the features requestesd for the reservation.
 *
 * @return On success, i.e. if the reservation was extended and an
 * answer was successfully sent to the requesting task, 0 is
 * returned. Or -1 in case of an error. The latter might happen
 * e.g. if the task or reservation was not found.
 */
int PSIDpart_extendRes(PStask_ID_t tid, PSrsrvtn_ID_t resID,
		       uint32_t got, PSpart_slot_t *slots);

#endif  /* __PSIDPARTITION_H */
