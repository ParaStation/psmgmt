/*
 * ParaStation
 *
 * Copyright (C) 2003-2004 ParTec AG, Karlsruhe
 * Copyright (C) 2005-2015 ParTec Cluster Competence Center GmbH, Munich
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined in the file LICENSE.QPL included in the packaging of this
 * file.
 */
/**
 * @file
 * Helper functions in order to setup and handle partitions.
 *
 * $Id$
 *
 * @author
 * Norbert Eicker <eicker@par-tec.com>
 *
 */
#ifndef __PSIDPARTITION_H
#define __PSIDPARTITION_H

#include "psprotocol.h"
#include "psnodes.h"
#include "pstask.h"
#include "psreservation.h"

#ifdef __cplusplus
extern "C" {
#if 0
} /* <- just for emacs indentation */
#endif
#endif

/**
 * @brief Initialize partition stuff
 *
 * Initialize the partition handling framework. This registers
 * the necessary message handlers.
 *
 * @return No return value.
 */
void initPartition(void);

/**
 * @brief Send a PSP_DD_GETTASKS message.
 *
 * Send a PSP_DD_GETTASKS message to the node with ParaStation ID @a
 * node. This message on the one hand requests a list of all running
 * tasks on the receiving node, on the other hand a list of all
 * pending partition request on the receiving node.
 *
 * Thus, this message will be answered by one or more
 * PSP_DD_PROVIDETASK messages and zero or more PSP_DD_GETPART
 * messages.
 *
 * Usually this message is generated by a new master node in order to
 * get an overview on the cluster status.
 *
 * @param node The node requested to send a list of active tasks
 * and pending partition requests.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_GETTASKS message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_GETTASKS(PSnodes_ID_t node);

/**
 * @brief Send a PSP_DD_TASKDEAD message.
 *
 * Send a PSP_DD_TASKDEAD message to the current master node.  This
 * message informs the master node on the exit of the root process
 * with task ID @a tid and thus allows to free the corresponding
 * partition.
 *
 * @param tid The task ID of the root process that exited.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKDEAD message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKDEAD(PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_TASKSUSPEND message.
 *
 * Send a PSP_DD_TASKSUSPEND message to the current master node. This
 * message informs the master node on the suspension of the root
 * process with task ID @a tid and thus probably allows to temporarily
 * free the corresponding partition.
 *
 * @param tid The task ID of the root process that was suspended.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKSUSPEND message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKSUSPEND(PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_TASKRESUME message.
 *
 * Send a PSP_DD_TASKRESUME message to the current master node. This
 * message informs the master node on the continuation of the root
 * process with task ID @a tid and thus probably to reallocate the
 * corresponding temporarily freed partition.
 *
 * @param tid The task ID of the root process that continues to run.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_TASKRESUME message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_TASKRESUME(PStask_ID_t tid);

/**
 * @brief Send a PSP_DD_CANCELPART message.
 *
 * Send a PSP_DD_CANCELPART message to the current master node.  This
 * message informs the master node on the exit of the root process
 * with task ID @a tid and thus allows to cancel the corresponding
 * partition request.
 *
 * @param tid The task ID of the root process that exited.
 *
 * @return On success, the number of bytes sent within the
 * PSP_DD_CANCELPART message is returned. If an error occurred, -1 is
 * returned and errno is set appropriately.
 */
int send_CANCELPART(PStask_ID_t tid);

/**
 * @brief Initialized partition handler.
 *
 * Initialize the partition handler machinery. This includes allocating
 * memory used to store centralized information on the allocated
 * partitions and pending partition requests.
 *
 * Usually this function is called upon detection that the local
 * daemon has to act as a master within the cluster.
 *
 * @return No return value.
 */
void initPartHandler(void);

/**
 * @brief Remove requests.
 *
 * Remove all requests originating from node @a node from the queue of
 * pending processes and from the queue of running processes.
 *
 * Within this function, the partition requests are actually not
 * removed from the queue, but only marked to get deleted within the
 * next round of handlePartRequests(). This is necessary to make this
 * function robust enough the get used from within a RDP callback.
 *
 * @param node The node whose request are going to be cleaned up.
 *
 * @return No return value.
 */
void cleanupRequests(PSnodes_ID_t node);

/**
 * @brief Shutdown partition handler.
 *
 * Shut down the partition handler machinery. This includes
 * freeing memory used to store centralized information on the
 * allocated partitions and pending partition requests as allocated
 * within @ref initPartHandler().
 *
 * Usually this function is called upon detection that the local
 * daemon is freed from the burden of acting as the master within the
 * cluster.
 *
 * @return No return value.
 */
void exitPartHandler(void);

/**
 * @brief Number of assigned SW-threads.
 *
 * Return the number of SW-threads assigned to node @a node.
 *
 * @param node The node to request.
 *
 * @return On success, the number of SW-threads assigned to the
 * requested node is returned, or 0, if an error occurred. Be aware of
 * the fact, that an error cannot be distinguished from an empty node.
 */
unsigned short getAssignedThreads(PSnodes_ID_t node);

/**
 * @brief The nodes exclusive flag.
 *
 * Return the flag marking node @a node to be used by its current job
 * exclusively.
 *
 * @param node The node to request.
 *
 * @return On success, the nodes exclusive flag is returned, i.e. the
 * flag marking the node to be used by its current job exclusively. Or
 * 0, if an error occurred. Be aware of the fact, that an error cannot
 * be distinguished from a node not used exclusively.
 */
int getIsExclusive(PSnodes_ID_t node);


/**
 * @brief Send list of requests.
 *
 * Send a list of partition-requests registered within the master
 * daemon. Depending on the flags set within @a opt, only pending,
 * running or suspended requests might be send to the @a requester.
 *
 * If @a ref PART_LIST_NODES is set in @a opt, also a list of the
 * processor slots allocated to the request is sent.
 *
 * @param requester Task ID of process waiting for answer.
 *
 * @param opt Option flags marking which type of requests to send and
 * format of answer (with/without list of slots).
 *
 * @return No return value.
 */
void sendRequestLists(PStask_ID_t requester, PSpart_list_t opt);

/**
 * @brief Collect slots from a task's list of HW-threads
 *
 * Collect @a np slots from @a task's list of HW-threads and store
 * them to the array @a slot. For this @a slots has to be large enough
 * to keep all created slots. Each slot will contain @a tpp HW-threads
 * located on the same node. Selection of HW-threads respects the
 * constraints given in @a option and @a hwType, i.e. the node
 * provides the requested hardware-type and flags like
 * PART_OPT_NODEFIRST or PART_OPT_OVERBOOK are taken into account. All
 * resources put into the list of slots are allocated, i.e. marked to
 * be busy.
 *
 * If the flag @a dryRun is set, actual allocation of resources is
 * omitted. I.e. the slots returned within the array @a slots shall
 * not actually be used but are just a hint on which result to expect
 * if the call is done with @a dryRun set to 0.
 *
 * @param np Number of slots to select
 *
 * @param hwType Hardware-type the HW-threads are required to have
 *
 * @param option Flags to consider when selecting HW-threads
 *
 * @param tpp Threads per process to be facilitated
 *
 * @param task Task structure holding the list of HW-threads
 *
 * @param slots The list of slots to create
 *
 * @param dryRun Flag to prevent actual allocation of resources
 *
 * @return The number of slots possible to select. If this is less
 * than @a np, no resources are actually allocated and the content of
 * @a slots is undefined. Nevertheless, calling again with the same
 * set of parameters and np replaced by the return value will be
 * successful.
 */
int PSIDpart_getNodes(uint32_t np, uint32_t hwType, PSpart_option_t option,
		      uint16_t tpp, PStask_t *task, PSpart_slot_t *slots,
		      int dryRun);

/**
 * @brief Register partition
 *
 * Register a partition as given within the @ref partThrds section of
 * the task-structure @a task. @ref partThrds is expected to hold a
 * list of HW-threads that the task is allowed to use as its
 * partition. For that, the @ref partition section will be created out
 * of the list of HW-threads and registered within the master psid.
 *
 * This mechanism shall be used in order to inform the master daemon
 * on partitioning decisions taken by some external resource
 * manager. Thus, it will be called primarily from inside psmom and
 * psslurm.
 *
 * @param task The task to register
 *
 * @return No return value
 */
void PSIDpart_register(PStask_t *task);

/**
 * @brief Send reservation's nodelist
 *
 * Send the nodelist of the reservation with ID @a resID belonging to
 * the task @a task to the destination stored in @a msg. The message
 * @a msg furthermore contains the sender and the message type used to
 * send one or more messages containing the list of
 * nodes. Additionally @a msg's buffer might contain some preset
 * content. Thus, its internally stored length (in the .len field) has
 * to correctly represent the messages preset content.
 *
 * In order to send the list of nodes, it is split into chunks. Each
 * chunk is copied into the message and send separately to its
 * destination.
 *
 * @param resID The ID of the reservation to investigate.
 *
 * @param task The task the reservation belongs to.
 *
 * @param msg The message buffer used to send the reservations node-list.
 *
 * @return No return value
 */
void PSIDpart_sendResNodes(PSrsrvtn_ID_t resID, PStask_t *task,
			   DDTypedBufferMsg_t *msg);

/**
 * @brief Cleanup reservations
 *
 * Cleanup all reservations associated to the task @a task. For this,
 * all HW-threads allocatd in reservations are marked as unused again
 * in the corresponding partition.
 *
 * @param task Task structure holding the reservations to cleanup
 *
 * @return No return value
 */
void PSIDpart_cleanupRes(PStask_t *task);

/**
 * @brief Cleanup reservered slots
 *
 * Cleanup all slots associated to the task @a task. These slots got
 * associated by PSP_CD_GETSLOTS messages sent by the task requesting
 * slots from a reservation in order to use them for spawning
 * processes later on.
 *
 * This function will create corresponding PSP_DD_CHILDRESREL messages
 * for each of the slots stored in the task's @ref spawnNodes
 * attribute not yet used for spawning.
 *
 * @param task Task structure holding the slots to cleanup
 *
 * @return No return value
 */
void PSIDpart_cleanupSlots(PStask_t *task);

#ifdef __cplusplus
}/* extern "C" */
#endif

#endif  /* __PSIDPARTITION_H */
