/*
 *               ParaStation
 *
 * Copyright (C) 2003-2004 ParTec AG, Karlsruhe
 * Copyright (C) 2005-2008 ParTec Cluster Competence Center GmbH, Munich
 *
 * $Id$
 *
 */
/**
 * \file
 * Handling of all input/output forwarding between logger and client.
 *
 * $Id$
 *
 * \author
 * Norbert Eicker <eicker@par-tec.com>
 *
 */
#ifndef __PSIDFORWARDER_H
#define __PSIDFORWARDER_H

#include "pstask.h"
#include "pslog.h"

#ifdef __cplusplus
extern "C" {
#if 0
} /* <- just for emacs indentation */
#endif
#endif

/** Connection Type of PMI */
typedef enum {
    PMI_DISABLED = 0,
    PMI_OVER_TCP,
    PMI_OVER_UNIX,
} PMItype_t;

/**
 * @brief The forwarder process.
 *
 * The actual forwarder process handling all input from stdin and
 * output to stdout and stderr operations of the controlled client
 * process. Therefore the forwarder process is connected to the local
 * daemon via which all communication operations of this kind are
 * delivered.
 *
 * Additionally it's the forwarders tasks to control the client
 * process' live and to supply post mortem failure and usage
 * information to the parent process.
 *
 * Furthermore the forwarder generates accounting messages, if @a
 * doAccounting is set different from 0. Every @a acctPollInterval
 * seconds the forwarder will poll on the /proc filesystem in order to
 * get more detailed information like memory consumption, etc. If @a
 * acctPollInterval is set to 0, no polling will take place.
 *
 * @param task Task structure describing the client process to control.
 *
 * @param daemonfd File descriptor connecting the forwarder to the
 * local daemon.
 *
 * @param PMISocket Socket connecting the forwarder to the pmi client.
 *
 * @param PMItype Defines if the pmi client is connected over tcp/ip or
 * over an unix domain socket which is the default.
 *
 * @param doAccounting Set to true if the forwarder should do accouting.
 *
 * @param acctPollInterval Interval in sec the forwarder will poll the
 * /proc filesystem for more detailed accounting information.
 *
 * @return No return value.
 */
void PSID_forwarder(PStask_t *task, int daemonfd, int PMISocket,
		    PMItype_t PMItype, int doAccounting, int acctPollInterval);

/**
 * @brief Send a message to the local daemon.
 *
 * Send the message @a msg to the local daemon.
 *
 * @param msg The message to send.
 *
 * @return On success, the number of bytes send is returned,
 * i.e. usually @a msg->header.len. Otherwise -1 is returned and errno
 * is set appropriately.
 */
int sendDaemonMsg(DDMsg_t *msg);

/**
 * @brief Send string to logger.
 *
 * Send the NULL terminated string stored within @a buf as a message
 * of type @a type to the logger. This is done via the PSLog facility.
 *
 * @param type The type of the message to send.
 *
 * @param buf Buffer holding the character string to send.
 *
 * @return On success, the number of bytes written is returned,
 * i.e. usually this is strlen(@a buf). On error, -1 is returned, and
 * errno is set appropriately.
 *
 * @see PSLog_print()
 */
int PSIDfwd_printMsg(PSLog_msg_t type, char *buf);

/** Maximum length of a message generated by @ref PSIDfwd_printMsgf */
#define PSIDfwd_printMsgf_len 512

/**
 * @brief Send string produced according to a format string to logger.
 *
 * Send a formated string via sendMsg. The generated message will be
 * truncated after @ref PSIDfwd_printMsgf_len bytes.
 *
 * @param type The type of the message to send.
 *
 * @param format snprintf like format string.
 *
 * @return On success, the number of bytes written is returned,
 * i.e. usually this is strlen(@a buf). On error, -1 is returned, and
 * errno is set appropriately.
 *
 * @see PSLog_print()
 */
int PSIDfwd_printMsgf(PSLog_msg_t type, const char *format, ...)
	__attribute__ ((__format__ (__printf__, 2, 3)));

#ifdef __cplusplus
}/* extern "C" */
#endif

#endif /* __PSIDFORWARDER_H */
