Klasse zur Jobverwaltung
  - Eigentliche Jobs:
    + Executable
    + Owner (UID/GID)
    + Laufzeit
    + Zahl der Knoten
    + Output (stdout/stderr)
    + Workdir
    + Weitere Limits ?
    + Diverse Zeiten (Submit/Start/Restart/End)
    + Verschiedene Environments (PATH, HOME, LANG, SHELL)
  - Liste solcher Jobs
    + Einfügen
    + Löschen
    + Suchen
    + ...
Persistente Jobs in Verzeichnissen (hashing)
Listen von wartenden und laufenden Jobs
Unix Socket zur Entgegennahme von neuen Jobs
Socket zum psid
select() wartet auf neue Jobs
Regelmäßig (alle x Sekunden):
  - nach freien Knoten/Prozessoren schauen
  - falls freie gefunden -> Job(s) starten
  - Job von "wartend" nach "laufend" verschieben
  - Job-Status in Datei verändern
Warten auf Signale:
  - Signal bei regulärem Jobende:
    + Output-Dateien auf richtigen Platz schieben
    + Eventuell Mail an Owner schicken
    + Job aus "laufen" löschen
    + Job-Datei löschen
Nach jedem neuen Job: Nächste Nummer hochzählen und speichern.
