From - Mon Jul  3 12:11:01 2000
Return-Path: <warschko@ira.uka.de>
Delivery-Date: Tue, 23 May 2000 18:05:23 +0200
Received: from iraun1.ira.uka.de (actually iraun1) by i41fs3 (PP) with ESMTP;
          Tue, 23 May 2000 18:05:22 +0200
Received: from Callisto.ira.uka.de (actually i41l2.ira.uka.de) by iraun1 (PP) 
          with ESMTP; Tue, 23 May 2000 18:09:22 +0200
Received: from Callisto.ira.uka.de (warschko@localhost [127.0.0.1]) 
          by Callisto.ira.uka.de (8.9.3/8.9.3/SuSE Linux 8.9.3-0.1) with ESMTP 
          id SAA15446; Tue, 23 May 2000 18:09:20 +0200
Message-Id: <200005231609.SAA15446@Callisto.ira.uka.de>
To: hauke@ira.uka.de
cc: warschko@ira.uka.de
Subject: MCP3 Design Ueberlegungen
Date: Tue, 23 May 2000 18:09:20 +0200
From: "Thomas Warschko, IPD, Uni Karlsruhe" <warschko@ira.uka.de>
Status: U
X-Mozilla-Status: 8001
X-Mozilla-Status2: 00000000
X-UIDL: 5cbcc69ce5b5d59ec7330cdd2f5460b1


ParaStation3 Paketaufbau:
=========================


  |  Byte3  |  Byte2  |  Byte1  |  Byte0  |
  |----------------------------------------
 4|             R O U T E
  |----------------------------------------
 8|             R O U T E
  |----------------------------------------
 c|        CONNID     |     TYPE
  |----------------------------------------
10|         LEN       |    SENDER
  |----------------------------------------
14|        SEQNO      |     ACKNO 
  |----------------------------------------
18|     SRC_PORT      |  DEST_PORT
  |----------------------------------------
20|     MSG_TAG       |    Reserved 
  |----------------------------------------
24|      DATA (bis zu 8192 Bytes)
  |
  |
  |
  |----------------------------------------



Datenstrukturen f"ur einen {\em address space} bzw. Kontext.
============================================================

a) im MCP
   - Paketpufferspeicher
   - Datenbereich zur "Ubergabe (Paketkopf)
     ca. 64 + 8 = 72KB pro Kontext

b) im HOST 
   - Datenbereich f"ur Kontrolldaten
   - Fenster (8kb) in die Doorbell Area
     ca. 8 KB pro Kontext
     (plus von der Applikation selbst gepostete recv-buffer)




Sendevorgang (Host -> MCP)

1) Zusammenstellung Paketheader (PIO)
2) DatenCopy (falls notwendig)
3) Notify mittels Schreiben in Doorbell-Area

Empfangsvorgang (MCP -> Host)




Flagabh"angigkeiten im MCP
==========================

NetSend: Start mit SMLT -> Fertig: SEND_INT_BIT
NetRecv: Start mit RML  -> Fertig: RECV_INT_BIT
			   Fehler: BUF_INT_BIT (buffer overflow)

PCI_DMA: Start mit PULSE (set WAKE in Flags) -> Fertig: WAKE_INT_BIT
FIFO:  -> Fertig(new entry): WAKE_INT_BIT
(ab LanAI9: WAKE_INT0/1/2)

IT0: (interval timer) -> fertig TIME0_INT_BIT
IT1: (interval timer) -> fertig TIME1_INT_BIT
IT2: (interval timer) -> fertig TIME2_INT_BIT



PSM_State_Bits:
===============
TIME0_INT_BIT    -> Retrans Timeout
WAKE_INT_BIT	 -> PCI_DMA finished | new HostRequest
RECV_INT_BIT     -> Reveived packet pending
BUF_INT_BIT      -> receive buffer overflow
SEND_INT_BIT     -> Net Send finished
DO_NETSEND       -> New Packet (or ACK/CTRL) to Send
DO_HOST_SEND     -> DMA to Host pending
HOSTSEND_PENDING -> DMA to Host in progress
DO_HOST_RECV	 -> DMA from Host pending
HOSTRECV_PENDING -> DMA from Host in progress



MCP Engine:
===========
unabh"angige State Machines:

1. NetSend
2. NetRecv
3. HostSend (MCP->host DMA)
4. HostRecv (host->MCP DMA)
5. WaitCheck (Finish PCI DMA, enqueue new Host requests)
6. TimeOut

NetRecv: (indication: RECV_INT_BIT)
  (1) Look for empty buffer
  (2) Restart Recv on new buffer
  (3) Check CRC (release if ERROR)
  (4) Process ACK 
  (5) release Buffer: if CRTL Packet
  (6) process Packet (release buffer if OOO -or no new empty buff avail)

NetSend: (indication: DO_NETSEND & SEND_INT_BIT)
  (1) locate next packet (CRTL or regular)
  (2) Complete Header
  (3) Start Send 
  (4) move packet to ack-Q (if regular)
  (5) update DO_NETSEND

HostSend: (indication: DO_HOST_SEND & !HOSTSEND_PENDING)
  (1) Setup DMA Chain
  (2) Fire DMA Chain
  (3) Set HOSTSEND_PENDING

HostRecv: (indication: DO_HOST_RECV & !HOSTRECV_PENDING)
  (1) Setup DMA Chain
  (2) Fire DMA Chain
  (3) Set HOSTRECV_PENDING

Waitcheck: (inidication: WAKE_INT_BIT)
  (1) Check Condition (which WAKE)
      FIFO: enqueu request (DO_HOST_RECV, DO_NETSEND)
      release HOSTSEND_PENDING, update DO_HOST_SEND 
      release HOSTRECV_PENDING, update DO_HOST_RECV 
  (2) release WAIT_INT_BIT

TimeOut: (indication TIME0_INT_BIT)
  (1) Enque Packet in NetSendQ
  (2) Clear TIME0_INT_BIT
  (3) Reprogram TimeOut Timer




Verwaltung Send - Buffer:

Jeder Kontext besitzt am Anfang NUM_SEND_BUF (=8) leere sende buffer (state = IDLE)
nach Datentransfer ist der Buffer bereit zum "ubertragen (state = READY) oder
nach einem DMA-Transfer bereit (state = DMA, dann state = READY). Nachdem
"Ubertragung l"auft ist state = INTRANSIT. In diesem Zustand bleibt er bis
(a) ein ACK kommt (dann state = ACKED), (b) ein NACK (dann state = RETRANSMIT), 
oder (c) ein Timeout (dann state = RETRANSMIT). Ist schlie"slich das ACK
eingeroffen, wird der Buffer wieder an den Host "ubergeben (state = IDLE).



Verwaltung Receive - Buffer:

Der MCP besitzt am Anfang NUM_RECV_BUF (~100-200) leere empfangspuffer (state = IDLE).
Wird ein Packet mit der richtigen sequenznummer empnfangen wechselt der Status auf
READY. Dann wird der Puffer an den Host "ubertragen (state = DMA) und schliesslich
wird der Puffer wieder freigegeben (state = IDLE).




Verwaltung ACK-Liste:

interne Liste, in die gesendete Puffer eingetragen werden.
pro zielknoten gibt es eine Liste in der die Puffer chonologisch eingeordnet 
sind. (beim Retransmit kann dann einfach die ganze Liste an die Net_send
List angeh"angt werden)

Verwaltung FREE-List:
Liste, in der alle freien Empfangspuffer stehen.


Verwaltung Task-Listen: Net_Send TL (MCP -> Net)
Liste, in der alle zu sendenden Pakete stehen. werden von "Waitcheck" eingetragen (neue Pakete)
oder vom ACK-Processing (Controllpakete), oder bei einem Timeout (Retransmission). Ist ein
Paket gesendet, wird der Eintrag verworfen (KontrollPaket) oder der Eintrag in die zielknoten
speziefische ACK-Liste eingetragen.


Verwaltung Task-Listen: Host_Send TL  (MCP -> Host)
Liste, in der alle zum Host zu transferierrenden pakete stehen. werden von NetReveive eingetragen.
Liste wird von HostRecv bearbeitet. Ist ein paket abgeliefert, wird der Puffer wieder in die
FREE-List einetragen.

