#!/usr/bin/perl -w
#
#               ParaStation
#
# Copyright (C) 1999-2004 ParTec AG, Karlsruhe
# Copyright (C) 2005-2007 ParTec Cluster Competence Center GmbH, Munich
#
# $Id$
#
#
# \file
# psaccview: ParaStation accounting log viewer
#
# $Id$
#
# \author
# Michael Rauh <rauh@par-tec.com>
#
#

use strict;
use Getopt::Long;
use Pod::Usage;

#################################################
## start of configuration
#################################################

my $ps_acc_dir="/var/account";

## Default output options 
my $noheader  		= "";
my $human 		= ""; 
my $listtotuser 	= "true";
my $listtotgroup 	= "true";
my $listtotsum  	= "true";
my $listjobs 		= "true";
my $timespan		= "year"; 	# today week month year
my $jsort		= "mem";
my $usort		= "user";
my $gsort		= "group";

## Default total display options
my $pu = "true";	# user
my $pg = "true";	# group
my $pw = "true";  	# walltime
my $pq = "true";	# qtime
my $pm = "true";      	# mem
my $pv = "true";	# vmem
my $pc = "true";	# cputime
my $pp = "true";	# jobs
my $pi = "true";	# procs 
my $pe = "true";	# cpu weight
my $pa = "true";	# average queue time 
my $pf = "true";	# usage 

## Default jobs display options
my $lu = "true";	# user
my $lg = "true";	# group
my $li = "true";	# jobid
my $ln = "true";	# jobname
my $lt = "true";	# start time
my $lb = "true";	# exit time
my $lw = "true"; 	# walltime
my $lq = "true";	# qtime
my $lm = "true";	# mem
my $lv = "true";	# vmem
my $lh = "";	        # not used yet # execution hosts
my $la = "";	        # not used yet # nodes
my $lc = "true";	# cpu time
my $le = "";	        # cpu weight
my $ld = "true";	# queue
my $lp = "true";	# processes
my $ls = "true";	# exit value

#################################################
## end of configuration
#################################################

my $fuser, my $fgroup, my $fqueue, my $fjobname, my $fexit;
my %total, my %acc_data, my $doptions, my $joptions, my $group;
my $olistjobs, my $olisttotuser, my $olisttotgroup, my $olisttotsum, my $help=0;
my $begin, my $end, my $tbegin, my $tend, my $version;
my $rev = '$Revision$';

## parse argv
GetOptions(
	   'jsort=s' 	  => \$jsort,
	   'usort=s'      => \$usort,
	   'gsort=s'      => \$gsort,
	   'human|h'      => \$human,
	   'noheader|nh'  => \$noheader,
	   'exit|e=s'     => \$fexit,
	   'queue|q=s'    => \$fqueue,
	   'user|u=s'     => \$fuser,
	   'group|g=s'    => \$fgroup,
	   'jobname|j=s'  => \$fjobname,
	   'ljobs|lj'     => \$olistjobs,
	   'ltotuser|lu'  => \$olisttotuser,
	   'ltotgroup|lg' => \$olisttotgroup,
	   'ltotsum|ls'   => \$olisttotsum,
	   'stotopt|st=s' => \$doptions,
	   'sjobopt|sj=s' => \$joptions,
	   'help|?'	  => \$help,
	   'timespan|t=s' => \$timespan,
	   'begin|tb=s'	  => \$begin,
	   'end|te=s'	  => \$end,
	   'logdir|l=s'  => \$ps_acc_dir,
           'version|v'    => \$version


)or pod2usage(2);
pod2usage(1) if $help;

if($version) {
        my $ver;
        ($ver=$rev)  =~s/(^.+: )([0-9]+)(.*)/$2/; 
        printf("\npsaccview version: $ver\n\n");
	exit(0);
}

if($olistjobs || $olisttotuser || $olisttotgroup || $olisttotsum){
	$listtotuser    = $olisttotuser  ? $olisttotuser        : "";
	$listtotgroup   = $olisttotgroup ? $olisttotgroup       : "";
	$listtotsum     = $olisttotsum   ? $olisttotsum         : "";
	$listjobs       = $olistjobs     ? $olistjobs           : "";
}

# parse total display options
if($doptions){ 
	
	$pu = "";	# user
	$pi = "";   	# procs 
	$pw = "";  	# walltime
	$pq = "";  	# qtime
	$pm = "";      	# mem
	$pv = "";	# vmem
	$pc = "";	# cputs
	$pp = "";	# jobs
	$pe = "";	# cpu weight
	$pa = "";	# average queue time 
	$pf = "";	# usage 
	
	my @popts = split(/,/,$doptions);
	foreach my $popt(@popts){
		$pu = $popt eq "user"      ? $pu = "true" : $pu;
		$pi = $popt eq "procs"     ? $pi = "true" : $pi;
		$pw = $popt eq "walltime"  ? $pw = "true" : $pw;
		$pq = $popt eq "qtime"     ? $pq = "true" : $pq;
		$pm = $popt eq "mem"       ? $pm = "true" : $pm;
		$pv = $popt eq "vmem"      ? $pv = "true" : $pv;
		$pc = $popt eq "cputime"   ? $pc = "true" : $pc;
		$pp = $popt eq "jobs"      ? $pp = "true" : $pp;
		$pe = $popt eq "cpuweight" ? $pe = "true" : $pe;
		$pa = $popt eq "aqtime"    ? $pa = "true" : $pa;
		$pf = $popt eq "usage"     ? $pf = "true" : $pf;
	}
}

# parse job display options
if($joptions){ 
	
	$lu = "";	# user
	$lg = "";	# group
	$li = "";	# jobid
	$ln = "";	# jobname
	$lt = "";	# start time
	$lb = "";	# exit time
	$lw = "";  	# walltime
	$lq = "";	# qtime
	$lm = "";	# mem
	$lv = "";	# vmem
	$lh = "";	# execution hosts
	$la = "";	# nodes
	$lc = "";	# cputs
	$le = "";	# cpu weight
	$ld = "";	# queue
	$lp = "";	# procs
	$ls = "";	# exit value
	
	my @popts = split(/,/,$joptions);
	foreach my $popt(@popts){
		
		$lu = $popt eq "user"      ? $lu = "true" : $lu;
		$lg = $popt eq "group"     ? $lg = "true" : $lg;
		$li = $popt eq "jobid"     ? $li = "true" : $li;
		$ln = $popt eq "jobname"   ? $ln = "true" : $ln;
		$lt = $popt eq "start"     ? $lt = "true" : $lt;
		$lb = $popt eq "end"       ? $lb = "true" : $lb;
		$lw = $popt eq "walltime"  ? $lw = "true" : $lw;
		$lq = $popt eq "qtime"     ? $lq = "true" : $lq;
		$lm = $popt eq "mem"       ? $lm = "true" : $lm;
		$lv = $popt eq "vmem"      ? $lv = "true" : $lv;
		$lh = $popt eq "exechosts" ? $lh = "true" : $lh;
		$la = $popt eq "nodes"     ? $la = "true" : $la;
		$lc = $popt eq "cputime"   ? $lc = "true" : $lc;
		$le = $popt eq "cpuweight" ? $le = "true" : $le;
		$ld = $popt eq "queue"     ? $ld = "true" : $ld;
		$lp = $popt eq "procs"     ? $lp = "true" : $lp;
		$ls = $popt eq "exit"      ? $ls = "true" : $ls;
	}
}


# calc time for filename
my @date = localtime(time);
$date[4]++;
$date[5] += 1900;
   
$tend = sprintf("%04d%02d%02d",$date[5],$date[4],$date[3]);
$tbegin = $tend if $timespan eq "today";
$tbegin = sprintf("%04d%02d01",$date[5],$date[4]) if $timespan eq "month";
$tbegin = sprintf("%04d0101",$date[5]) if $timespan eq "year";
if($timespan eq "week"){
	@date = localtime(time - ($date[6] * 86400));
   	$date[4]++;
	$date[5] += 1900;
	$tbegin = sprintf("%04d%02d%02d",$date[5],$date[4],$date[3]);
}

$tend  = $end if $end;
$tbegin = $begin if $begin;

$tbegin = 1 if $timespan eq "all";
#print "start:$tbegin,end:$tend\n";

my $jobnum = 0;
my $mestime = time;
my $lbegin = $tend;

my %job_data, my %user_data, my %group_data, my %sum_data; 

my @testa;
# Read acc log files
opendir(DIR, $ps_acc_dir) or die("Can't open accounting directory for reading !");
while ( defined (my $filename = readdir(DIR))) {
	my $show = "cat";
	if($filename =~ /\.(gz)$/){$show = "gzip -cd"; }
	if($filename =~ /\.(bz2)$/){$show = "bzip2 -cd"; }
	my $basename = $filename;
	$basename =~ s/(\.(gz)$)|(\.(bz2)$)//; 
	$lbegin = $basename if ($basename =~  /^\d{8}$/ && $basename < $lbegin);
	if($filename eq ".." || $filename eq "." || $basename !~ /^\d{8}$/ || $basename < $tbegin || $basename > $tend){next;}	
	#printf "$filename $basename\n";
	open FILE,"$show " . $ps_acc_dir. "/" . $filename . " |"  or die("Can't open file $filename");
	my @lines = <FILE>;
	close FILE;
	foreach my $line (@lines) {
		my @parts = split(/;/,$line);
		if ( $parts[1] && $parts[1] eq "E" ) {
			my @jobid = split(/\./,$parts[2]);
			my @subdata = split(/ /,$parts[3]);
			my $group , my $user, my $qtime ,my $jobname, my $start, my $queue, my $cput; 
			my $mem, my $vmem, my $walltime, my $exechost, my $exitstatus, my $end;
			foreach my $accline (@subdata) {
				($user=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^user=/;  
				($group=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^group=/;  
				($jobname=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^jobname=/; 
 				($queue=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^queue=/;  
				($qtime=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^qtime=/; 
				($start=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^start=/; 
				($end=$accline)	 	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^end=/; 
				($exitstatus=$accline) 	 =~s/(^.+=)(-?[0-9]+)(\n*)/$2/ if $accline =~ /^Exit_status=/;
				($cput=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^resources_used.cput=/;  
				($mem=$accline)	 	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^resources_used.mem=/;  
				($vmem=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^resources_used.vmem=/;  
				($walltime=$accline)	 =~s/(^.+=)(.*)/$2/ if $accline =~ /^resources_used.walltime=/;
				($exechost=$accline)     =~s/(^.+=)(.*)/$2/ if $accline =~ /^exec_host=/;
			}

			if((!defined($fuser)    || $fuser eq $user) &&
			   (!defined($fgroup)   || $fgroup eq $group) &&
			   (!defined($fqueue)   || $fqueue eq $queue) &&
			   (!defined($fexit)    || ($fexit eq $exitstatus) 
			     || ($fexit eq "false" && $exitstatus != 0) ) &&
			   (!defined($fjobname) || $fjobname eq $jobname)){
				
				my @exec_hosts = split(/\+/,$exechost);
			        my $num_hosts = scalar(@exec_hosts);
	
				if($listjobs){
					$job_data{$jobnum}{'user'} = $user;
					$job_data{$jobnum}{'group'} = $group;
					$job_data{$jobnum}{'jobname'} = $jobname;
					$job_data{$jobnum}{'jobid'} = $jobid[0];
					$job_data{$jobnum}{'queue'} = $queue;
					$job_data{$jobnum}{'cputime'} = time_to_sec($cput);
					$job_data{$jobnum}{'mem'} = kb_to_num($mem);
					$job_data{$jobnum}{'vmem'} = kb_to_num($vmem);
					$job_data{$jobnum}{'walltime'} = time_to_sec($walltime);
					$job_data{$jobnum}{'qtime'} = $start - $qtime;
					$job_data{$jobnum}{'start'} = $start;
					$job_data{$jobnum}{'end'} = $end;
					$job_data{$jobnum}{'exit'} = $exitstatus;
					$job_data{$jobnum}{'cpuweight'} = $num_hosts * time_to_sec($walltime);
					$job_data{$jobnum}{'procs'} = $num_hosts;
				}	

				if($listtotuser){
					$user_data{$user}{'cputime'} += time_to_sec($cput);
					$user_data{$user}{'mem'} += kb_to_num($mem);
					$user_data{$user}{'vmem'} += kb_to_num($vmem);
					$user_data{$user}{'walltime'} += time_to_sec($walltime);
					$user_data{$user}{'qtime'} += $start - $qtime;
					$user_data{$user}{'cpuweight'} += $num_hosts * time_to_sec($walltime);
					$user_data{$user}{'procs'} += $num_hosts;
					$user_data{$user}{'jobs'} += 1;
				}

				if($listtotgroup){
					$group_data{$group}{'cputime'} += time_to_sec($cput);
					$group_data{$group}{'mem'} += kb_to_num($mem);
					$group_data{$group}{'vmem'}+= kb_to_num($vmem);
					$group_data{$group}{'walltime'} += time_to_sec($walltime);
					$group_data{$group}{'qtime'} += $start - $qtime;
					$group_data{$group}{'cpuweight'} += $num_hosts * time_to_sec($walltime);
					$group_data{$group}{'procs'} += $num_hosts;
					$group_data{$group}{'jobs'} += 1;
					
				}
				
				$sum_data{'walltime'} += time_to_sec($walltime);
				if($listtotsum){
					$sum_data{'cputime'} += time_to_sec($cput);
					$sum_data{'mem'} += kb_to_num($mem);
					$sum_data{'vmem'} += kb_to_num($vmem);
					$sum_data{'qtime'} += $start - $qtime;
					$sum_data{'cpuweight'} += $num_hosts * time_to_sec($walltime);
					$sum_data{'procs'} += $num_hosts;
					$sum_data{'jobs'} += 1;
				}

				$jobnum++;
			}
		}
	}
}

#die;
close DIR;

# Check if we have data left
if(!$jobnum){ die "No accounting data is matching your search criteria\n"; }


if(!$noheader){
	print "\nParaStation accouting statistics\n--------------------------------\n\n";

	my $bY, my $bM, my $bD, my $eY, my $eM, my $eD;
	$tbegin = $lbegin if $tbegin == 1;	
	$bY = substr($tbegin,0,4);
	$bM = substr($tbegin,4,2);
	$bD = substr($tbegin,6,2);	
	$eY = substr($tend,0,4);
	$eM = substr($tend,4,2);
	$eD = substr($tend,6,2);	

	if($ENV{'LANG'} =~ /en_US/){ print "From $bY/$bM/$bD till $eY/$eM/$eD\n\n";}
	else { print "From $bD.$bM.$bY till $eD.$eM.$eY\n\n"; }
	
}

if($listtotuser){

	# Calc the max space
	my $maxu = 4;
	my $maxp = 4;
	my $maxi = 5;
	my $maxw = 8;
	my $maxc = 7;
	my $maxq = 5;
	my $maxm = 3;
	my $maxv = 4; 
	my $maxe = 9;
	my $maxa = 9;
	my $maxf = 5;

	foreach my $usr ( keys %user_data) {
		$maxu = length($usr) > $maxu ? length($usr) : $maxu;		
		$maxp = length($user_data{$usr}{'jobs'}) > $maxp ? length($user_data{$usr}{'jobs'}) : $maxp;
		$maxi = length($user_data{$usr}{'procs'}) > $maxi ? length($user_data{$usr}{'procs'}) : $maxi;
		if(!$human){
			$maxw = length($user_data{$usr}{'walltime'}) > $maxw ? length($user_data{$usr}{'walltime'}) : $maxw;
			$maxc = length($user_data{$usr}{'cputime'}) > $maxc ? length($user_data{$usr}{'cputime'}) : $maxc;
			$maxq = length($user_data{$usr}{'qtime'}) > $maxq ? length($user_data{$usr}{'qtime'}) : $maxq;
			$maxm = length($user_data{$usr}{'mem'}) > $maxm ? length($user_data{$usr}{'vmem'}) : $maxm;
			$maxv = length($user_data{$usr}{'vmem'}) > $maxv ? length($user_data{$usr}{'vmem'}) : $maxv;
			$maxe = length($user_data{$usr}{'cpuweight'}) > $maxe ? length($user_data{$usr}{'cpuweight'}) : $maxe;
			$maxa = length(int(($user_data{$usr}{'qtime'}) / ($user_data{$usr}{'jobs'}))) > $maxa ? length(int(($user_data{$usr}{'qtime'}) / ($user_data{$usr}{'jobs'}))) : $maxa;
		}
		else{
			$maxw = length(formattimep($user_data{$usr}{'walltime'})) > $maxw ? length(formattimep($user_data{$usr}{'walltime'})) : $maxw;
			$maxc = length(formattimep($user_data{$usr}{'cputime'})) > $maxc ? length(formattimep($user_data{$usr}{'cputime'})) : $maxc;
			$maxq = length(formattimep($user_data{$usr}{'qtime'})) > $maxq ? length(formattimep($user_data{$usr}{'qtime'})) : $maxq;
			$maxm = length(formatmem($user_data{$usr}{'mem'})) > $maxm ? length(formatmem($user_data{$usr}{'mem'})) : $maxm;
			$maxv = length(formatmem($user_data{$usr}{'vmem'})) > $maxv ? length(formatmem($user_data{$usr}{'vmem'})) : $maxv;
			$maxe = length(formattimep($user_data{$usr}{'cpuweight'})) > $maxe ? length(formattimep($user_data{$usr}{'cpuweight'})) : $maxe;
			$maxa = length(formattimep(int(($user_data{$usr}{'qtime'}) / ($user_data{$usr}{'jobs'})))) > $maxa ? length(formattimep(int(($user_data{$usr}{'qtime'}) / ($user_data{$usr}{'jobs'})))) : $maxa;
		}	
		
	}	

	my $diff = 3;
	my $format = "";
	$format .= $pu ? "%-".($maxu+$diff)."s" : "%s";
	$format .= $pp ? "%".($maxp)."s"." "x$diff : "%s";
	$format .= $pi ? "%".($maxi)."s"." "x$diff : "%s";
	$format .= $pw ? "%".($maxw)."s"." "x$diff : "%s";
	$format .= $pc ? "%".($maxc)."s"." "x$diff : "%s";
	$format .= $pq ? "%".($maxq)."s"." "x$diff : "%s";
	$format .= $pm ? "%".($maxm)."s"." "x$diff : "%s";
	$format .= $pv ? "%".($maxv)."s"." "x$diff : "%s";
	$format .= $pe ? "%".($maxe)."s"." "x$diff : "%s";
	$format .= $pa ? "%".($maxa)."s"." "x$diff : "%s";
	$format .= $pf ? "%".($maxf)."s" : "%s";
  
  
	if(!$noheader){

		printf($format,
		$pu ? "User"  : "",
		$pp ? "Jobs" : "",
		$pi ? "Procs" : "",
		$pw ? "Walltime" : "",
		$pc ? "CPUtime" : "",
		$pq ? "Qtime" : "",
		$pm ? "Mem" : "",
		$pv ? "Vmem" : "",
		$pe ? "CPUweight" : "",
		$pa ? "Avg Qtime" : "",
		$pf ? "Usage" : "",
		);

		printf("\n".$format,
		$pu ? "-"x$maxu : "" , 
		$pp ? "-"x$maxp : "",
		$pi ? "-"x$maxi : "",
		$pw ? "-"x$maxw : "",
		$pc ? "-"x$maxc : "",
		$pq ? "-"x$maxq : "",
		$pm ? "-"x$maxm : "",
		$pv ? "-"x$maxv : "",
		$pe ? "-"x$maxe : "",
		$pa ? "-"x$maxa : "",
		$pf ? "-"x$maxf : "",
		);

		print "\n";
	} 



	my $sfunc;
	$sfunc = \&sunh;
	
	$sfunc = \&snorm if ($usort =~ /user/); 

	foreach my $usr (sort $sfunc (keys %user_data)) {
			printf($format."\n",
				$pu ? $usr : "",
				$pp ? $user_data{$usr}{'jobs'} : "",
				$pi ? $user_data{$usr}{'procs'} : "",
				$pw ? formattimep($user_data{$usr}{'walltime'}) : "",
				$pc ? formattimep($user_data{$usr}{'cputime'}) : "",
				$pq ? formattimep($user_data{$usr}{'qtime'}) : "" ,
				$pm ? formatmem($user_data{$usr}{'mem'}) : "" ,
				$pv ? formatmem($user_data{$usr}{'vmem'}) : "",
				$pe ? formattimep($user_data{$usr}{'cpuweight'}) : "", 
				$pa ? formattimep(int(($user_data{$usr}{'qtime'}) / ($user_data{$usr}{'jobs'})))   : "" ,
				$pf ? int($user_data{$usr}{'walltime'}  / $sum_data{'walltime'}  * 100) . "%" : "", 
				);
		}	

	

	print "\n\n";
}

if($listtotgroup){

	# Calc the max space
	my $maxg = 5;
	my $maxi = 5;
	my $maxp = 4;
	my $maxw = 8;
	my $maxc = 7;
	my $maxq = 5;
	my $maxm = 3;
	my $maxv = 4; 
	my $maxe = 9;
	my $maxa = 9;
	my $maxf = 5;

	foreach my $grp (keys %group_data) {
		$maxg = length($grp) > $maxg ? length($grp) : $maxg;		
		$maxp = length($group_data{$grp}{'jobs'}) > $maxp ? length($group_data{$grp}{'jobs'}) : $maxp;
		$maxi = length($group_data{$grp}{'procs'}) > $maxi ? length($group_data{$grp}{'procs'}) : $maxi;
		if(!$human){
			$maxw = length($group_data{$grp}{'walltime'}) > $maxw ? length($group_data{$grp}{'walltime'}) : $maxw;
			$maxc = length($group_data{$grp}{'cputime'}) > $maxc ? length($group_data{$grp}{'cputime'}) : $maxc;
			$maxq = length($group_data{$grp}{'qtime'}) > $maxq ? length($group_data{$grp}{'qtime'}) : $maxq;
			$maxm = length($group_data{$grp}{'mem'}) > $maxm ? length($group_data{$grp}{'vmem'}) : $maxm;
			$maxv = length($group_data{$grp}{'vmem'}) > $maxv ? length($group_data{$grp}{'vmem'}) : $maxv;
			$maxe = length($group_data{$grp}{'cpuweight'}) > $maxe ? length($group_data{$grp}{'cpuweight'}) : $maxe;
			$maxa = length(int(($group_data{$grp}{'qtime'}) / ($group_data{$grp}{'jobs'}))) > $maxa ? length(int(($group_data{$grp}{'qtime'}) / ($group_data{$grp}{'jobs'}))) : $maxa;
		}
		else{
			$maxw = length(formattimep($group_data{$grp}{'walltime'})) > $maxw ? length(formattimep($group_data{$grp}{'walltime'})) : $maxw;
			$maxc = length(formattimep($group_data{$grp}{'cputime'})) > $maxc ? length(formattimep($group_data{$grp}{'cputime'})) : $maxc;
			$maxq = length(formattimep($group_data{$grp}{'qtime'})) > $maxq ? length(formattimep($group_data{$grp}{'qtime'})) : $maxq;
			$maxm = length(formatmem($group_data{$grp}{'mem'})) > $maxm ? length(formatmem($group_data{$grp}{'mem'})) : $maxm;
			$maxv = length(formatmem($group_data{$grp}{'vmem'})) > $maxv ? length(formatmem($group_data{$grp}{'vmem'})) : $maxv;
			$maxe = length(formattimep($group_data{$grp}{'cpuweight'})) > $maxe ? length(formattimep($group_data{$grp}{'cpuweight'})) : $maxe;
			$maxa = length(formattimep(int(($group_data{$grp}{'qtime'}) / ($group_data{$grp}{'jobs'})))) > $maxa ? length(formattimep(int(($group_data{$grp}{'qtime'}) / ($group_data{$grp}{'jobs'})))) : $maxa;
		}	
			
	}

	my $diff = 3;
	my $format = "";
	$format .= $pg ? "%-".($maxg+$diff)."s" : "%s";
	$format .= $pp ? "%".($maxp)."s"." "x$diff : "%s";
	$format .= $pi ? "%".($maxi)."s"." "x$diff : "%s";
	$format .= $pw ? "%".($maxw)."s"." "x$diff : "%s";
	$format .= $pc ? "%".($maxc)."s"." "x$diff : "%s";
	$format .= $pq ? "%".($maxq)."s"." "x$diff : "%s";
	$format .= $pm ? "%".($maxm)."s"." "x$diff : "%s";
	$format .= $pv ? "%".($maxv)."s"." "x$diff : "%s";
	$format .= $pe ? "%".($maxe)."s"." "x$diff : "%s";
	$format .= $pa ? "%".($maxa)."s"." "x$diff : "%s";
	$format .= $pf ? "%".($maxf)."s"." "x$diff : "%s";
  
  
	if(!$noheader){

		printf($format,
		$pg ? "Group" : "",
		$pp ? "Jobs" : "",
		$pi ? "Procs" : "",
		$pw ? "Walltime" : "",
		$pc ? "CPUtime" : "",
		$pq ? "Qtime" : "",
		$pm ? "Mem" : "",
		$pv ? "Vmem" : "",
		$pe ? "CPUweight" : "",
		$pa ? "Avg Qtime" : "",
		$pf ? "Usage" : "",
		);

		printf("\n".$format,
		$pg ? "-"x$maxg : "",
		$pp ? "-"x$maxp : "",
		$pi ? "-"x$maxi : "",
		$pw ? "-"x$maxw : "",
		$pc ? "-"x$maxc : "",
		$pq ? "-"x$maxq : "",
		$pm ? "-"x$maxm : "",
		$pv ? "-"x$maxv : "",
		$pe ? "-"x$maxe : "",
		$pa ? "-"x$maxa : "",
		$pf ? "-"x$maxf : "",
		);

		print "\n";
	} 

	my $sfunc = \&sgh; 
	
	$sfunc = \&snorm if ($gsort =~ /group/); 
	

	foreach my $grp (sort $sfunc (keys %group_data)) {
		printf($format."\n",
			$pg ? $grp : "",
			$pp ? $group_data{$grp}{'jobs'} : "",
			$pi ? $group_data{$grp}{'procs'} : "",
			$pw ? formattimep($group_data{$grp}{'walltime'}) : "",
			$pc ? formattimep($group_data{$grp}{'cputime'}) : "",
			$pq ? formattimep($group_data{$grp}{'qtime'}) : "" ,
			$pm ? formatmem($group_data{$grp}{'mem'}) : "" ,
			$pv ? formatmem($group_data{$grp}{'vmem'}) : "",
			$pe ? formattimep($group_data{$grp}{'cpuweight'}) : "", 
			$pa ? formattimep(int(($group_data{$grp}{'qtime'}) / ($group_data{$grp}{'jobs'})))   : "" ,
			$pf ? int($group_data{$grp}{'walltime'}  /  $sum_data{'walltime'} * 100) . "%" : "", 
			);
			
		
	
	}

	print "\n\n";

}


if($listtotsum){

	# Calc the max space
	my $maxp = 4;
	my $maxi = 5;
	my $maxw = 8;
	my $maxc = 7;
	my $maxq = 5;
	my $maxm = 3;
	my $maxv = 4; 
	my $maxe = 9;
	my $maxa = 9;
	my $maxf = 5;

	$maxp = length($sum_data{'jobs'}) > $maxp ? length($sum_data{'jobs'}) : $maxp;
	$maxi = length($sum_data{'procs'}) > $maxi ? length($sum_data{'procs'}) : $maxi;
	if(!$human){
		$maxw = length($sum_data{'walltime'}) > $maxw ? length($sum_data{'walltime'}) : $maxw;
		$maxc = length($sum_data{'cputime'}) > $maxc ? length($sum_data{'cputime'}) : $maxc;
		$maxq = length($sum_data{'qtime'}) > $maxq ? length($sum_data{'qtime'}) : $maxq;
		$maxm = length($sum_data{'mem'}) > $maxm ? length($sum_data{'vmem'}) : $maxm;
		$maxv = length($sum_data{'vmem'}) > $maxv ? length($sum_data{'vmem'}) : $maxv;
		$maxe = length($sum_data{'cpuweight'}) > $maxe ? length($sum_data{'cpuweight'}) : $maxe;
		$maxa = length(int(($sum_data{'qtime'}) / ($sum_data{'jobs'}))) > $maxa ? length(int(($sum_data{'qtime'}) / ($sum_data{'jobs'}))) : $maxa;
	}
	else{
		$maxw = length(formattimep($sum_data{'walltime'})) > $maxw ? length(formattimep($sum_data{'walltime'})) : $maxw;
		$maxc = length(formattimep($sum_data{'cputime'})) > $maxc ? length(formattimep($sum_data{'cputime'})) : $maxc;
		$maxq = length(formattimep($sum_data{'qtime'})) > $maxq ? length(formattimep($sum_data{'qtime'})) : $maxq;
		$maxm = length(formatmem($sum_data{'mem'})) > $maxm ? length(formatmem($sum_data{'mem'})) : $maxm;
		$maxv = length(formatmem($sum_data{'vmem'})) > $maxv ? length(formatmem($sum_data{'vmem'})) : $maxv;
		$maxe = length(formattimep($sum_data{'cpuweight'})) > $maxe ? length(formattimep($sum_data{'cpuweight'})) : $maxe;
		$maxa = length(formattimep(int(($sum_data{'qtime'}) / ($sum_data{'jobs'})))) > $maxa ? length(formattimep(int(($sum_data{'qtime'}) / ($sum_data{'jobs'})))) : $maxa;
	}	
			
	my $diff = 3;
	my $format = "";
	$format .= "%-".(7 + $diff)."s";
	$format .= $pp ? "%".($maxp)."s"." "x$diff : "%s";
	$format .= $pi ? "%".($maxi)."s"." "x$diff : "%s";
	$format .= $pw ? "%".($maxw)."s"." "x$diff : "%s";
	$format .= $pc ? "%".($maxc)."s"." "x$diff : "%s";
	$format .= $pq ? "%".($maxq)."s"." "x$diff : "%s";
	$format .= $pm ? "%".($maxm)."s"." "x$diff : "%s";
	$format .= $pv ? "%".($maxv)."s"." "x$diff : "%s";
	$format .= $pe ? "%".($maxe)."s"." "x$diff : "%s";
	$format .= $pa ? "%".($maxa)."s"." "x$diff : "%s";
  
  
  if(!$noheader){

	printf($format,
	"Summary",
	$pp ? "Jobs" : "",
	$pi ? "Procs" : "",
	$pw ? "Walltime" : "",
	$pc ? "CPUtime" : "",
	$pq ? "Qtime" : "",
	$pm ? "Mem" : "",
	$pv ? "Vmem" : "",
	$pe ? "CPUweight" : "",
	$pa ? "Avg Qtime" : "",
	);

	printf("\n".$format,
	"-------",
	$pp ? "-"x$maxp : "",
	$pi ? "-"x$maxi : "",
	$pw ? "-"x$maxw : "",
	$pc ? "-"x$maxc : "",
	$pq ? "-"x$maxq : "",
	$pm ? "-"x$maxm : "",
	$pv ? "-"x$maxv : "",
	$pe ? "-"x$maxe : "",
	$pa ? "-"x$maxa : "",
	);

	print "\n";
    } 

	printf($format."\n",
		"TOTAL",
		$pp ? $sum_data{'jobs'} : "",
		$pi ? $sum_data{'procs'} : "",
		$pw ? formattimep($sum_data{'walltime'}) : "",
		$pc ? formattimep($sum_data{'cputime'}) : "",
		$pq ? formattimep($sum_data{'qtime'}) : "" ,
		$pm ? formatmem($sum_data{'mem'}) : "" ,
		$pv ? formatmem($sum_data{'vmem'}) : "",
		$pe ? formattimep($sum_data{'cpuweight'}) : "", 
		$pa ? formattimep(int(($sum_data{'qtime'}) / ($sum_data{'jobs'})))   : "" ,
		);

	print "\n\n";

}


if($listjobs){

	my $maxu = 4;
	my $maxg = 5;
	my $maxi = 5;
	my $maxn = 7;
	my $maxt = 5;
	my $maxb = 3;
	my $maxw = 8;
	my $maxq = 5;
	my $maxm = 3;
	my $maxv = 4; 
	my $maxh = 5;
	my $maxc = 7;
	my $maxd = 5;
	my $maxe = 9;
	my $maxa = 9;
	my $maxf = 5;
	my $maxp = 5;
	my $maxs = 4;

	#listjobs options
	my $lh = "s";  # execution hosts
	my $la = "s";  # nodes

	foreach my $jobnum (keys %job_data) {
		$maxu = length($job_data{$jobnum}{'user'}) > $maxu ? length($job_data{$jobnum}{'user'}) : $maxu;		
		$maxg = length($job_data{$jobnum}{'group'}) > $maxg ? length($job_data{$jobnum}{'group'}) : $maxg;		
		$maxi = length($job_data{$jobnum}{'jobid'}) > $maxi ? length($job_data{$jobnum}{'jobid'}) : $maxi;		
		$maxd = length($job_data{$jobnum}{'queue'}) > $maxd ? length($job_data{$jobnum}{'queue'}) : $maxd;		
		$maxn = length($job_data{$jobnum}{'jobname'}) > $maxn ? length($job_data{$jobnum}{'jobname'}) : $maxn;		
		$maxp = length($job_data{$jobnum}{'procs'}) > $maxp ? length($job_data{$jobnum}{'procs' }) : $maxp;
		$maxs = length($job_data{$jobnum}{'exit'}) > $maxs ? length($job_data{$jobnum}{'exit' }) : $maxs;

		if(!$human){
			$maxw = length($job_data{$jobnum}{'walltime'}) > $maxw ? length($job_data{$jobnum}{'walltime'}) : $maxw;
			$maxt = length($job_data{$jobnum}{'start'}) > $maxt ? length($job_data{$jobnum}{'start'}) : $maxt;		
			$maxb = length($job_data{$jobnum}{'end'}) > $maxb ? length($job_data{$jobnum}{'end'}) : $maxb;		
			$maxc = length($job_data{$jobnum}{'cputime'}) > $maxc ? length($job_data{$jobnum}{'cputime'}) : $maxc;
			$maxq = length($job_data{$jobnum}{'qtime'}) > $maxq ? length($job_data{$jobnum}{'qtime'}) : $maxq;
			$maxm = length($job_data{$jobnum}{'mem'}) > $maxm ? length($job_data{$jobnum}{'vmem'}) : $maxm;
			$maxv = length($job_data{$jobnum}{'vmem'}) > $maxv ? length($job_data{$jobnum}{'vmem'}) : $maxv;
			$maxe = length($job_data{$jobnum}{'cpuweight'}) > $maxe ? length($job_data{$jobnum}{'cpuweight'}) : $maxe;
			$maxa = length(int(($job_data{$jobnum}{'qtime'}) / ($job_data{$jobnum}{'procs'}))) > $maxa ? length(int(($job_data{$jobnum}{'qtime'}) / ($job_data{$jobnum}{'procs'}))) : $maxa;
		}
		else{
			$maxw = length(formattimep($job_data{$jobnum}{'walltime'})) > $maxw ? length(formattimep($job_data{$jobnum}{'walltime'})) : $maxw;
			$maxt = length(formattime($job_data{$jobnum}{'start'})) > $maxt ? length(formattime($job_data{$jobnum}{'start'})) : $maxt;		
			$maxb = length(formattime($job_data{$jobnum}{'end'})) > $maxb ? length(formattime($job_data{$jobnum}{'end'})) : $maxb;		
			$maxc = length(formattimep($job_data{$jobnum}{'cputime'})) > $maxc ? length(formattimep($job_data{$jobnum}{'cputime'})) : $maxc;
			$maxq = length(formattimep($job_data{$jobnum}{'qtime'})) > $maxq ? length(formattimep($job_data{$jobnum}{'qtime'})) : $maxq;
			$maxm = length(formatmem($job_data{$jobnum}{'mem'})) > $maxm ? length(formatmem($job_data{$jobnum}{'mem'})) : $maxm;
			$maxv = length(formatmem($job_data{$jobnum}{'vmem'})) > $maxv ? length(formatmem($job_data{$jobnum}{'vmem'})) : $maxv;
			$maxe = length(formattimep($job_data{$jobnum}{'cpuweight'})) > $maxe ? length(formattimep($job_data{$jobnum}{'cpuweight'})) : $maxe;
			$maxa = length(formattimep(int(($job_data{$jobnum}{'qtime'}) / ($job_data{$jobnum}{'procs'})))) > $maxa ? length(formattimep(int(($job_data{$jobnum}{'qtime'}) / ($job_data{$jobnum}{'procs'})))) : $maxa;
		}	
			
	}


	my $diff = 3;
	my $format = "";
	$format .= $lu ? "%-".($maxu+$diff)."s" : "%s";
	$format .= $lg ? "%-".($maxg+$diff)."s" : "%s";
	$format .= $ln ? "%-".($maxn+$diff)."s" : "%s";
	$format .= $ld ? "%-".($maxd+$diff)."s" : "%s";
	$format .= $li ? "%".($maxi)."s"." "x$diff : "%s";
	$format .= $lp ? "%".($maxp)."s"." "x$diff : "%s";
	$format .= $lt ? "%".($maxt)."s"." "x$diff : "%s";
	$format .= $lb ? "%".($maxb)."s"." "x$diff : "%s";
	$format .= $lw ? "%".($maxw)."s"." "x$diff : "%s";
	$format .= $lq ? "%".($maxq)."s"." "x$diff : "%s";
	$format .= $lm ? "%".($maxm)."s"." "x$diff : "%s";
	$format .= $lv ? "%".($maxv)."s"." "x$diff : "%s";
	#$format .= $lh ? "%".($maxh)."s"." "x$diff : "%s";
	#$format .= $la ? "%".($maxa)."s"." "x$diff : "%s";
	$format .= $lc ? "%".($maxc)."s"." "x$diff : "%s";
	$format .= $le ? "%".($maxe)."s"." "x$diff : "%s";
	$format .= $ls ? "%".($maxs)."s"." "x$diff : "%s";
  
  	if(!$noheader){
	
		printf($format,
		$lu ? "User"  : "",
		$lg ? "Group" : "",
		$ln ? "Jobname" : "",
		$ld ? "Queue" : "",
		$li ? "Jobid" : "",
		$lp ? "Procs" : "",
		$lt ? "Start" : "",
		$lb ? "End" : "",
		$lw ? "Walltime" : "",
		$lq ? "Qtime" : "",
		$lm ? "Mem" : "",
		$lv ? "Vmem" : "",
		#$lh ? "Exec Hosts" : "",
		#$la ? "Nodes" : "",
		$lc ? "CPUtime" : "",
		$le ? "CPUweigth" : "",
		$ls ? "Exit" : ""
		);

		printf("\n".$format,
		$lu ? "-"x$maxu : "", 
		$lg ? "-"x$maxg : "",
		$ln ? "-"x$maxn : "",
		$ld ? "-"x$maxd : "",
		$li ? "-"x$maxi : "",
		$lp ? "-"x$maxp : "",
		$lt ? "-"x$maxt : "",
		$lb ? "-"x$maxb : "",
		$lw ? "-"x$maxw : "",
		$lq ? "-"x$maxq : "",
		$lm ? "-"x$maxm : "",
		$lv ? "-"x$maxv : "",
		#$lh ? "-"x$maxh : "",
		#$la ? "-"x$maxa : "",
		$lc ? "-"x$maxc : "",
		$le ? "-"x$maxe : "",
		$ls ? "-"x$maxs : ""
		);
		print "\n";
	}
	
	my $sfunc;
	if ($jsort =~ /user/ || $jsort =~ /group/ || $jsort =~ /jobname/ 
	   || $jsort =~ /queue/ ) { 

		$sfunc = \&sbh; 
	} else {
		$sfunc = \&snh;
	
	}
	   
	foreach my $jobnum (sort $sfunc (keys %job_data) ) {
		
		printf($format."\n",
			$lu ? $job_data{$jobnum}{'user'} : "",
			$lg ? $job_data{$jobnum}{'group'} : "",
			$ln ? $job_data{$jobnum}{'jobname'} : "",
			$ld ? $job_data{$jobnum}{'queue'} : "",
			$li ? $job_data{$jobnum}{'jobid'} : "",
			$lp ? $job_data{$jobnum}{'procs'} : "",
			$lt ? formattime($job_data{$jobnum}{'start'}) : "",
			$lb ? formattime($job_data{$jobnum}{'end'}) : "",
			$lw ? formattimep($job_data{$jobnum}{'walltime'}) : "",
			$lq ? formattimep($job_data{$jobnum}{'qtime'}) : "" ,
			$lm ? formatmem($job_data{$jobnum}{'mem'}) : "" ,
			$lv ? formatmem($job_data{$jobnum}{'vmem'}) : "",
			#$lh ? $job_data{$jobnum}{'exechosts'} : "",
			#$la ? $job_data{$jobnum}{'nodes'} : "",
			$lc ? formattimep($job_data{$jobnum}{'cputime'}) : "",
			$le ? formattimep($job_data{$jobnum}{'cpuweight'}) : "",
			$ls ? $job_data{$jobnum}{'exit'} : "" 
			);
		
	   }	

	   print "\n\n";

}

## Search functions

sub sbh {
	$job_data{$a}{$jsort} cmp $job_data{$b}{$jsort};
	
}


sub snh {
	$job_data{$a}{$jsort} <=> $job_data{$b}{$jsort};
	
}

sub subh {
	$user_data{$a}{$usort} cmp $user_data{$b}{$usort};
	
}


sub sunh {
	$user_data{$a}{$usort} <=> $user_data{$b}{$usort};
	
}

sub sgh {
	$group_data{$a}{$gsort} <=> $group_data{$b}{$gsort};
	
}

sub snorm {
	$a cmp $b;
}


sub kb_to_num {
	if(!$_[0]){ return 0 };
	(my $out = $_[0]) =~ s/kb//;
	return $out;
}

sub time_to_sec {
	if(!$_[0]){ return 0 };
	my $hours = "";
	my $min = "";
	my $secs = "";
	($hours,$min,$secs)=split(/:/,$_[0]);
	return ($hours * 3600) + ($min * 60) + $secs;
}

sub formattime {

	my $NOW=$_[0];
	if($human && $NOW){

		my $y=sprintf("%02d",(localtime($NOW))[5]-100);
		my $Y=sprintf("%04d",(localtime($NOW))[5]+1900);
		my $m=sprintf("%02d",(localtime($NOW))[4]+1);
		my $d=sprintf("%02d",(localtime($NOW))[3]);
		my $H=sprintf("%02d",(localtime($NOW))[2]);
		my $M=sprintf("%02d",(localtime($NOW))[1]);
		my $S=sprintf("%02d",(localtime($NOW))[0]);

		if($ENV{'LANG'} =~ /en_US/){ return "$Y/$m/$d $H:$M" };
		return "$d.$m.$Y $H:$M";
	}
	return $NOW;
}


sub formattimep {
	
	my $out = $_[0];
	if($human){
		my $days = int ($out / 86400);
		$out -= $days * 86400 if $days >0;
		my $hours = int ($out / 3600);
		$out -= $hours * 3600 if $hours >0;
		my $min = int ($out / 60);
		$out -= int ($min * 60) if $min >0;
		my $sec = $out;
		my $time = "";

		$time .= $days  > 0 ? $days."d "  : "";
		
		if($hours > 0 ){
			$time .= $hours."h ";
		}

		if($hours <=0 && $days >0){
			$time .= "0h ";
		}

		if($min > 0 ){
			$time .= $min."m ";
		}

		if($min <= 0 && $days > 0 && $hours > 0){
			$time .= "0m ";
		}
		
		$time .= $sec   > 0 ? $sec."s"    : "0s";
		
		return $time;
	}
	return $out;
}


sub formatmem {
	
	my $mem = $_[0];
	if($human){
		$mem = int($mem/1024);
		return $mem." MB";
	}
	return $mem;
}


my $meetime = time;
if(!$noheader){print "Used parse time: ".formattimep($meetime - $mestime)."\n";}


__END__

=head1 NAME


ParaStation accouting statistics

=head1 SYNOPSIS

psaccview [options]

  Options:
	--human --noheader --exit {value} --queue {value}
	--user {value} --group {value} --jobname {value}
	--ljobs --ltotuser --ltotgroup --ltotsum 
	--stotopt {string}  --sjobopt {string} --help 
	--timespan {today,week,month,year} --logdir {value}
	--begin {yyyymmdd} --end {yyyymmdd} --version
	--jsort {value} --usort {value} --gsort {value}


=head1 OPTIONS

=over 4

=item B<--help -?>

Displays this help screen.

=item B<--human -h>

Displays the output human readable.


=item B<--noheader -nh>

Outputs the data without any header information. Usefull for 
further parsing.


=item B<--exit -e> <exitcode>

Shows only results with the given exit code. You can use "false" as exit
code to get all jobs where the exit code is not 0.


=item B<--queue -q> <queue>

Shows only results from the given queue.


=item B<--user -u> <user>

Shows only results from the given user name.


=item B<--group -g> <group>

Shows only results from the given group.


=item B<--jobname -j> <jobname>

Show only results form the given jobname.

=item B<--logdir -l>

Set directory to read the accouting log files from.

=item B<--ljobs -lj>

Lists all jobs.


=item B<--ltotuser -lu>

Lists a summary from all jobs per user.


=item B<--ltotgroup -lg>

Lists a summary form all jobs per group.


=item B<--ltotsum -ls>

Lists a total summary of all jobs.


=item B<--stotopt -st> <optstring>

Set which rows should be displayed in the total summary lists. Valid rows are:
'user', 'group', 'walltime', 'qtime', 'mem', 'vmem', 'cputime', 'jobs', 'cpuweight',
'aqtime', 'usage'

Example: -st "user,group,cputime,usage"

=item B<--sjobopt -sj> <optstring>

Set which rows should be displayed in the job list. 
Valid rows are:
'user', 'group', 'jobid', 'jobname', 'start', 'end', 'walltime', 'qtime', 'mem', 
'vmem', 'cputime', 'cpuweight', 'queue', 'procs', 'exit'

Example: -sj "user,group,jobname,procs,exit"

=item B<--timespan -t> <span>

Selects a period of time. Valid values are 'today', 'week', 'month', 'year', 'all'.

=item B<--begin -b> <yyyymmdd>

Selects the begin time of the log.

Example: -b 20070501

=item B<--end -e> <yyyymmdd>

Selects the end time of the log. If not set the end time is always today.

Example: -e 20070901

=item B<--jsort> <criteria>

Defines witch criteria to use for sorting the job list.
Valid values are:
'user', 'group', 'jobid', 'jobname', 'start', 'end', 'walltime', 'qtime', 'mem',
'vmem', 'cputime', 'queue', 'procs', 'exit'

=item B<--usort> <criteria>

Defines witch criteria to use for sorting the jobs per user list. 
Valid values are:
'user', 'jobs', 'walltime', 'qtime', 'mem', 'vmem', 'cputime', 'procs', 'cpuweight'
     
=item B<--gsort> <criteria>

Defines witch criteria to use for sorting the jobs per group list.
Valid values are:
'group', 'jobs', 'walltime', 'qtime', 'mem', 'vmem', 'cputime', 'procs', 'cpuweight'

=item B<--version -v>

Display version information and exit.

=back

=cut
