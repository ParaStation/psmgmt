#!/bin/bash
#
#       Copyright (c) 2003 ParTec AG Karlsruhe
#       All rights reserved.
# @author
#       Jens Hauke <hauke@par-tec.de>
#
# (Friday noon vision of a parallel shell :-)
#
# The configfile could look like this:
#${HOME}/.psh.d/default:
#-n carla[1-4]
#node carla14
#max 16

D_CONFIG_D="${HOME}/.psh.d"
D_CONFIG="${D_CONFIG_D}/default"
D_RCMD="ssh -x -oConnectTimeout=10"
D_MAXRCMD=128
D_AUTOCD="cd ${PWD/#${HOME}/~} &&"
TMPTEMPLATE="/tmp/pshout.XXXXXX"

############################
# Use mpiexec/pssh if available?

#if [ -f "/opt/parastation/bin/mpiexec" ] ; then
#    PARASTATIONSTART="/opt/parastation/bin/mpiexec"
#    $PARASTATIONSTART --checkup 1>/dev/null 2>&1 \
#    && USE_MPIEXEC="TRUE" && D_RCMD="$PARASTATIONSTART -A -N"
#else
#    PARASTATIONSTART="/opt/parastation/bin/pssh"
#fi

#if [ -x "${PARASTATIONSTART}" ] ; then
#    D_RCMD="${PARASTATIONSTART}";
#fi

#############################
# create a default template
if [ ! -e "${D_CONFIG}" ] ; then
    read -n 1 -p "Create ${D_CONFIG} [y/N]? " q
    echo
    case "$q" in
    y|Y)
        mkdir -p ${D_CONFIG_D}
        cat >> ${D_CONFIG} <<EOF
## psh defaults
## uncomment all options you need...

## default nodelist:
# node nodename[01-16]

## default remote command:
# rcmd pssh
# rcmd ssh -x

## dont start more than 1 remote shell at the same time?
# max 1

## be always verbose ?
# verbose

EOF
        ;;
    esac
fi

####################################################
# alternative default? (hostname%dx,hostnamex,default)
tmp=$(hostname -s)
if [ -e "${D_CONFIG_D}/${tmp}" ] ; then
    D_CONFIG=${D_CONFIG_D}/${tmp}
else
    tmp=${tmp//[0-9]/}
    if [ -e "${D_CONFIG_D}/${tmp}" ] ; then
	D_CONFIG=${D_CONFIG_D}/${tmp}
    fi
fi

#######################

function help
{
cat <<EOF
Usage: psh [OPTION]... command
       psh [OPTION]... -sync filename...
       psh [OPTION]... -sync dirname...

Options:
   -g|-group {group}      : Use group defined in $D_CONFIG_D
                            (default "default")
   -c|-configfile {cfile} : Set configuration file
                            (default "$D_CONFIG").
   -n|-node {node,...}    : Append {node} to nodelist.
   -x|-xnode {node,...}   : Exclude {node} from nodelist.
   -s|-sync               : copy one file to all nodes.
   -rcmd {rcmd}           : set remote shell (default "$D_RCMD").
   -max {nmax}            : dont start more than {nmax} remote shells
                            at the same time (default $D_MAXRCMD).
   -autocd                : remote dir (default "cd \${PWD/\${HOME}/~};")
                            use -autocd "" to disable autocd.
   -v|-verbose            : Be verbose
   -h|-help               : help
EOF
}

function parse()
{
#    echo Parse "$*"
    case "$1" in
	-g|${prearg}group)
            CONFIG="${CONFIG_D}/$2"
	    nopts=2
	    ;;
	-c|${prearg}configfile)
	    CONFIG="$2"
	    nopts=2
	    ;;
	-n|${prearg}node)
	    if [ "${cmd_line_nodes-0}" = 0 ];then
		NODES=(${NODES[*]} $(psnameexpand "$2"))
		nopts=2
	    fi
	    ;;
	-s|-sync)
	    SYNC=1
	    nopts=1
	    ;;
	${prearg}rcmd)
	    RCMD=${RCMD-"$2"}
	    nopts=2
	    ;;
	${prearg}max)
	    MAXRCMD=${MAXRCMD-"$2"}
	    nopts=2
	    ;;
	-x|${prearg}xnode)
	    XNODES=(${XNODES[*]} $(psnameexpand "$2"))
	    nopts=2
	    ;;
	${prearg}autocd)
	    AUTOCD=${AUTOCD-"$2"}
	    nopts=2
	    ;;
	-v|${prearg}verbose)
	    VERBOSE=1
	    nopts=1
	    ;;
	-h|${prearg}help)
	    help
	    exit 1
	    ;;
	${prearg}#*) # comment
	    nopts=1
	    ;;
	${prearg}*)
	    echo "$optsource : unknown option \"$1\"."
	    help
	    exit 1;
	    ;;
	*)
	    nopts=0;
    esac
}

function cleanup
{
#    echo Cleanup called
    if [ x"$TMPFILES" != x ]; then
	# clenaup in background:
	rm $TMPFILES &
    fi
}

#
# merge hostnames (e.g. host001 host002 to host[001-002])
#
function psregexp(){
    # see ftp://ftp.cwru.edu/pub/bash/FAQ E14, why we
    # need a function for it.
    [[ "$1" =~ $2 ]]
}


function psnameexpand_group(){
    local name="$1"

    # Split "," separated elements
    while psregexp "$name" '^([^,]*),(.*)'; do
	name="${BASH_REMATCH[2]}"
	psnameexpand_group "${BASH_REMATCH[1]}"
    done

    # nummeric range?
    if psregexp "$name" '^([0-9]+)-([0-9]+)'; then
	# yes
	local from="${BASH_REMATCH[1]}" to="${BASH_REMATCH[2]}"
	seq -f "%0${#from}g" "$from" "$to"
    else
	echo "$name"
    fi
}


function psnameexpand(){
    #-- Expand names with group syntax (e.g. node[03-06,09],nodex
    #-- parameters:
    #   $*: names to expand
    #-- Result newline separated list of names usable for
    #   for i in $(psnameexpand "$names"); do
    #

    # Call psnameexpand with all arguments:
    while [ $# -gt 1 ]; do psnameexpand "$1"; shift; done

    local name="$1"

    # Split "," separated names, but keep "[x,y]"
    while psregexp "$name" '^(([^[,]|\[[^]]*\])*),(.*)'; do
	name="${BASH_REMATCH[3]}"
	psnameexpand "${BASH_REMATCH[1]}"
    done

    # Expand first group "[]"
    if psregexp "$name" '^([^[]*)\[([^]]*)\](.*)'; then
	local i
	local prefix="${BASH_REMATCH[1]}" postfix="${BASH_REMATCH[3]}"
	for i in $(psnameexpand_group "${BASH_REMATCH[2]}"|tr ' ' ,); do
	    # transforming ' ' to ',' will preserve ' ' in groups. '\t' will
	    # still be lost.
	    psnameexpand "${prefix}${i//,/ }${postfix}"
	done
    else
	# No groups left.
	# In case of a nummeric range psnameexpand_group will evaluate
	# it. Else psnameexpand_group is like a 'echo "$name"'
	psnameexpand_group "$name"
    fi
}


function psnamecompress(){
    local name
    local pre num post
    local start group
    local last=("$@") result=()

    while true; do
	for name in "${last[@]}" $'end\001end'; do
	    # In range?
	    if [ -n "$start" ]; then
		local lnum="$num"

		# eval next expected number
		num=$((10#$num + 1))
		while (( "${#num}" < "${#start}" ));do num="0$num"; done

		if [ "${pre}${num}${post}" = "$name" ]; then
		    # expected value. $name is in a range.
		    continue
		fi

		# flush current range
		[ -n "$group" ] && group="$group,"
		case $((10#$num - 10#$start)) in
		    1) group="${group}${start}";;
		    2) group="${group}${start},${lnum}";;
		    *) group="${group}${start}-${lnum}";;
		esac
		start=""

		if psregexp "$name" '^(([^[0-9]|[0-9]+[^[0-9])*)([0-9]+)(.*)' &&
		    [ "$pre" = "${BASH_REMATCH[1]}" ] &&
		    [ "$post" = "${BASH_REMATCH[4]}" ]; then
		    # Not in range, but in same group
		    num="${BASH_REMATCH[3]}"
		    start="$num"
		    continue
		fi

		# Complete new name, flush current group
		result=( "${result[@]}" "${pre}[${group}]$post" )
		group=""
		ngroup=""
	    fi

	    # End of loop?
	    [ "$name" = $'end\001end' ] && break

	    # New range?
	    if psregexp "$name" '^(([^[0-9]|[0-9]+[^[0-9])*)([0-9]+)(.*)'; then
		pre="${BASH_REMATCH[1]}" num="${BASH_REMATCH[3]}" post="${BASH_REMATCH[4]}"
		start="$num"
	    else
		result=("${result[@]}" "$name")
	    fi
	    :
	done
	if [ "${last[*]}" == "${result[*]}" ]; then
	    break;
	fi

	last=("${result[@]}")
	result=()
    done

    # echo result with removed "one element group" group symbol "[]".
    (export IFS=','; echo "${result[*]}") | sed 's/\[\([0-9]\+\)\]/\1/g'
}


#
# remove $1 from nodelist
#
function del_node()
{
    NODES=" ${NODES[*]} "
    NODES=(${NODES/" $1 "/" "})
}


#
# Just fetch SIGINT
#
function killcurrent
{
    echo kill $WAITFOR
}

#
# Wait until the next process ends and collect the exit code.
#
function ecollect
{
    ii=${#EXITCODES[*]}
    WAITFOR=${PIDS[$ii]}
    if [ "$VERBOSE" = 1 ];then
	echo "Wait for ${NODES[${#EXITCODES[*]}]} (pid ${PIDS[$ii]})"
    fi
    wait ${PIDS[$ii]}
    ec="$?"
    if [ "$ec" != "0" ]; then
	echo "Exit $ec" >> ${OUTPUTS[$ii]}
    fi
    EXITCODES=(${EXITCODES[*]} "$ec")
}

trap cleanup EXIT

CONFIG="$D_CONFIG"
CONFIG_D="$D_CONFIG_D"

#
# Parse commandline
#
optsource="Commandline"
prearg="-"
nopts=1
while [ $nopts != 0 ] ; do
    parse "$@"
    shift $nopts
done

#
# Read configuration
#
prearg=""
cmd_line_nodes="${#NODES[*]}"

if [ -f "${CONFIG}" ]; then
    line=0
    while read command opts; do
	line=$(( $line + 1 ))
	optsource="$CONFIG:$line"
	if [ ! -z "$command" ]; then
	    parse "$command" "$opts"
	fi
    done < "${CONFIG}"
fi

COMMAND="$*"

if [ x"$COMMAND" = x ];then
    if [ x"$SYNC" = x ]; then
	echo "Error: Missing command"
    else
	echo "Error: Missing filename"
    fi
    help
    exit 1
fi

if [ "${#NODES[*]}" = 0 ];then
    echo "Error: No nodes"
    help
    exit 1
fi

for((i = 0 ;i < ${#XNODES[*]} ;i++)); do
    del_node ${XNODES[$i]}
done


RCMD="${RCMD-$D_RCMD}"
MAXRCMD="${MAXRCMD-$D_MAXRCMD}"
AUTOCD="${AUTOCD-$D_AUTOCD}"

if [ "${SYNC}" = 1 ]; then
    FILELIST="$COMMAND"
    COMMAND="tar xvPf -";
    TARFILE=$(mktemp $TMPTEMPLATE)
    TMPFILES="$TMPFILES $TARFILE"
    echo "Prepare files for distribution:"
    tar cvPf "${TARFILE}" ${FILELIST}
    echo "Continue(y/n)?[n]"
    read c
    case "$c" in
	y|Y)
	;;
	*)
	    exit 1;
    esac
    INPUT="${TARFILE}"
else
    INPUT="/dev/null"
fi



if [ "$VERBOSE" = 1 ];then
cat <<EOF
CONFIG  ${D_CONFIG}
NODES   ${NODES[*]}
NODESSHORT $(psnamecompress ${NODES[*]})
RCMD    $RCMD
COMMAND $COMMAND
EOF
fi

## Use specal syntax for mpiexec
if [ "$USE_MPIEXEC" == "TRUE" ] ; then
    nodes=${NODES[*]}
    $RCMD "$nodes" $COMMAND
    exit 0
fi


trap killcurrent SIGINT

#
# Start remote jobs
#
for ((i = 0; i < ${#NODES[*]} ; i++)); do
    host=${NODES[$i]}
    OUTFILE=$(mktemp $TMPTEMPLATE)
    TMPFILES="$TMPFILES $OUTFILE"
    OUTPUTS=(${OUTPUTS[*]} ${OUTFILE})
    < "${INPUT}" $RCMD "$host" "$AUTOCD$COMMAND" > $OUTFILE 2>&1 &
    PIDS=(${PIDS[*]} $!)
    if [ "$VERBOSE" = 1 ];then
	echo "$RCMD $host $COMMAND"
    fi
    if [ $(($i + 1)) -ge "$MAXRCMD" ]; then
	ecollect
    fi
done

#
# Wait for finish
#
for ((i = ${#EXITCODES[*]}; i < ${#NODES[*]} ; i++)); do
    ecollect
done

#
# Merge outputs
#

# calculate all md5 sums
for ((i = 0; i < ${#OUTPUTS[*]} ; i++)); do
    out="${OUTPUTS[$i]}"
    MD5S[$i]=$(md5sum $out|(read a b && echo $a))
done

for ((i = 0; i < ${#NODES[*]} ; i++)); do
    hosts=${NODES[$i]}
    if [ "${DISPLAYED[$i]}" != "1" ]; then
	# search for equal outputs
	for ((ii = $i + 1; ii < ${#NODES[*]} ; ii++)); do
	    if [ "${DISPLAYED[$ii]}" != "1" ]; then
      #	    echo Compare ${OUTPUTS[$i]} ${OUTPUTS[$ii]}
		if [ "${MD5S[$i]}" = "${MD5S[$ii]}" ]; then
		    hosts="$hosts ${NODES[$ii]}"
		    DISPLAYED[$ii]="1";
		fi
	    fi
	done
	echo "=== $(psnamecompress $hosts)"
	cat ${OUTPUTS[$i]}
    fi
done
