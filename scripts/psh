#!/bin/bash
#
#       Copyright (c) 2003 ParTec AG Karlsruhe
#       All rights reserved.
# @author
#       Jens Hauke <hauke@par-tec.de>
#
# (Friday noon vision of a parallel shell :-)
#
# The configfile could look like this:
#${HOME}/.psh.d/default:
#-n carla[1-4]
#node carla14
#max 16

D_CONFIG_D="${HOME}/.psh.d"
D_CONFIG="${D_CONFIG_D}/default"
D_RCMD="ssh -x -oConnectTimeout=10"
D_MAXRCMD=32
D_DIFFCMD="diff -q"
D_AUTOCD="cd ${PWD/#${HOME}/~} &&"
TMPTEMPLATE="/tmp/pshout.XXXXXX"

############################
# Use mpiexec/pssh if available?

#if [ -f "/opt/parastation/bin/mpiexec" ] ; then
#    PARASTATIONSTART="/opt/parastation/bin/mpiexec"
#    $PARASTATIONSTART --checkup 1>/dev/null 2>&1 \
#    && USE_MPIEXEC="TRUE" && D_RCMD="$PARASTATIONSTART -A -N"
#else
#    PARASTATIONSTART="/opt/parastation/bin/pssh"
#fi

#if [ -x "${PARASTATIONSTART}" ] ; then
#    D_RCMD="${PARASTATIONSTART}";
#fi

#############################
# create a default template
if [ ! -e "${D_CONFIG}" ] ; then
    read -n 1 -p "Create ${D_CONFIG} [y/N]? " q
    echo
    case "$q" in
    y|Y)
        mkdir -p ${D_CONFIG_D}
        cat >> ${D_CONFIG} <<EOF
## psh defaults
## uncomment all options you need...

## default nodelist:
# node nodename[01-16]

## default remote command:
# rcmd pssh
# rcmd ssh -x

## dont start more than 1 remote shell at the same time?
# max 1

## be always verbose ?
# verbose

EOF
        ;;
    esac
fi

####################################################
# alternative default? (hostname%dx,hostnamex,default)
tmp=$(hostname -s)
if [ -e "${D_CONFIG_D}/${tmp}" ] ; then
    D_CONFIG=${D_CONFIG_D}/${tmp}
else
    tmp=${tmp//[0-9]/}
    if [ -e "${D_CONFIG_D}/${tmp}" ] ; then
	D_CONFIG=${D_CONFIG_D}/${tmp}
    fi
fi

#######################

function help
{
cat <<EOF
Usage: psh [OPTION]... command
       psh [OPTION]... -sync filename...
       psh [OPTION]... -sync dirname...

Options:
   -g|-group {group}      : Use group defined in $D_CONFIG_D
                            (default "default")
   -c|-configfile {cfile} : Set configuration file
                            (default "$D_CONFIG").
   -n|-node {node,...}    : Append {node} to nodelist.
   -x|-xnode {node,...}   : Exclude {node} from nodelist.
   -s|-sync               : copy one file to all nodes.
   -rcmd {rcmd}           : set remote shell (default "$D_RCMD").
   -max {nmax}            : dont start more than {nmax} remote shells
                            at the same time (default $D_MAXRCMD).
   -diff {cmd}            : Program which compares the outputs
                            (default "$D_DIFFCMD")
   -autocd                : remote dir (default "cd \${PWD/\${HOME}/~};")
                            use -autocd "" to disable autocd.
   -v|-verbose            : Be verbose
   -h|-help               : help
EOF
}

function parse()
{
#    echo Parse "$*"
    case "$1" in
	-g|${prearg}group)
            CONFIG="${CONFIG_D}/$2"
	    nopts=2
	    ;;
	-c|${prearg}configfile)
	    CONFIG="$2"
	    nopts=2
	    ;;
	-n|${prearg}node)
	    if [ "${cmd_line_nodes-0}" = 0 ];then
		NODES=(${NODES[*]} $(NameExpand "$2"))
		nopts=2
	    fi
	    ;;
	-s|-sync)
	    SYNC=1
	    nopts=1
	    ;;
	${prearg}rcmd)
	    RCMD=${RCMD-"$2"}
	    nopts=2
	    ;;
	${prearg}max)
	    MAXRCMD=${MAXRCMD-"$2"}
	    nopts=2
	    ;;
	${prearg}diff)
	    DIFFCMD=${DIFFCMD-"$2"}
	    nopts=2
	    ;;
	-x|${prearg}xnode)
	    XNODES=(${XNODES[*]} $(NameExpand "$2"))
	    nopts=2
	    ;;
	${prearg}autocd)
	    AUTOCD=${AUTOCD-"$2"}
	    nopts=2
	    ;;
	-v|${prearg}verbose)
	    VERBOSE=1
	    nopts=1
	    ;;
	-h|${prearg}help)
	    help
	    exit 1
	    ;;
	${prearg}#*) # comment
	    nopts=1
	    ;;
	${prearg}*)
	    echo "$optsource : unknown option \"$1\"."
	    help
	    exit 1;
	    ;;
	*)
	    nopts=0;
    esac
}

function cleanup
{
#    echo Cleanup called
    if [ x"$TMPFILES" != x ]; then
	rm $TMPFILES
    fi
}

#
# merge hostnames (e.g. host001 host002 to host[001-002])
#
###=== fg functions start ===
# $1: name expression
# $2: width (optional)
function SingleNameExpand()
{
	local prefix
	local rangelist
	local suffix
#	local rangefrom		# required if using printf with $format
#	local rangeto
#	local -i width
#	local format
	local nlist=""
	local name
	local -i gwidth=${2:-0}
	local range

	prefix=${1%%\[*\]*};
	rangelist=${1##$prefix};
	suffix=${rangelist#*\]};
	rangelist=${rangelist%"$suffix"};
	rangelist=${rangelist/\[/}
	rangelist=${rangelist/\]/}
	[[ $range =~ [^0-9-] ]] && return 1
#	rangefrom=${rangelist%-*};	# required if using printf with $format
#	rangeto=${rangelist#*-};
#	width=${#rangefrom}

#	Empty prefix is allowed, return a list of numbers (ids)
#	[ -z "$prefix" ] && { return 1; }

	[ -z "$rangelist" ] && {	# there is no range at all
		echo $prefix$suffix;
		return 0;
	}

	[[ "$suffix" =~ \[*\] ]] && {
		suffix=$(SingleNameExpand $suffix)
		[ $? -gt 0 ] && return 1
	}

	for range in ${rangelist//","/" "}
	do
		[[ $range =~ [^0-9-] ]] && return 1
		local rangefromstr=${range%-*};
		[ -z "$rangefromstr" ] && return 1
		local -i rangefrom=10#${rangefromstr}
		local -i rangeto=10#${range#*-};
		local -i width=${#rangefromstr}

		(( width < gwidth )) && width=$gwidth
		(( gwidth == 0 )) && gwidth=$width
#		local format="%s%0${width}d%s"

		(( rangefrom > rangeto )) && { return 1; }

		while (( rangefrom <= rangeto ))
		do
			for suf in ${suffix}X	# add X to handle empty list
			do
#				don't use printf, it's slow!!!
#				name=$(printf ${format} "$prefix" "$rangefrom" "$suf")
				local leadin=""
				local -i n
				let n=$width-${#rangefrom};
				while (( n > 0 ))
				do
					leadin="${leadin}0"
					let n--
				done
				name=$prefix$leadin$rangefrom$suf
				name=${name%X}
				# check for duplicate nodes
#				[[ $nlist =~ "[ ]+$name[ ]+" ]] && {
#					return 1
#				}
				nlist="${nlist}${name} "
			done
			let rangefrom++

		done
	done
	echo $nlist
	return
}

# $1: name list expression, like jj[01-3]c[08-10,12],jf02c[02-3]s
# $2: width (optional)
function NameExpand()
{
	local nlist=""
	local name
	local pattern

	# bash lacks of the ability to match these patterns
	for i in $(echo $1 | sed -e 's/\([]a-zA-Z_]\),/\1 /g' -e 's/,\([a-zA-Z_]\)/ \1/g')
	do
		local list="$(SingleNameExpand $i $2)"
		[ $? -gt 0 ] && return 1
		for name in $list
		do
			# check for duplicate nodes
			pattern="^${name} | ${name} "
			[[ $nlist =~ $pattern ]] && {
				return 1
			}
		done
		# new list is valid, append it to already known list of nodes
		nlist="$nlist$list "
	done
	echo $nlist

	return
}

# $1: eat count
# $2-: names
function NameCompressLevel()
{
	local x1=$@
	local -i eatcount=$1; shift
	local suffix=${1##*[][0-9]}
	local name=${1%$suffix}; shift
	# rip off all aa[1-2] as indicated by eatcount
	local -i i=$eatcount
	while [[ $name =~ [a-z]*[][0-9,-]+$ ]]
	do
		(( i-- <= 0 )) && break
		ripoff=${BASH_REMATCH[0]}
		suffix=$ripoff$suffix
		ripoff=${ripoff/[/\\[}
		ripoff=${ripoff/]/\\]}
		name=${name%$ripoff}
	done

	local numstr=${name};
	numstr=${numstr##*[a-zA-Z_]}
	local -i num=10#${numstr}
	local prefix=${name%$numstr}

	local suffix2="" prefix2="" name2="" numstr2
	local -i num2
	local -i rangefrom=10#$num
	local -i rangeto=10#$num
	local nlist=""
	local width=${#numstr}
	local range=""

	while [ $# -gt 0 ]
	do
		local x2=$1
		suffix2=${1##*[][0-9]}
		name2=${1%$suffix2}; shift
		# rip off all aa[1-2] as indicated by eatcount
		i=$eatcount
		while [[ $name2 =~ [a-z]*[][0-9,-]+$ ]]
		do
			(( i-- <= 0 )) && break
			ripoff=${BASH_REMATCH[0]}
			suffix2=$ripoff$suffix2
			ripoff=${ripoff/[/\\[}
			ripoff=${ripoff/]/\\]}
			name2=${name2%$ripoff}
		done

		numstr2=${name2};
		numstr2=${numstr2##*[a-zA-Z_]}
		prefix2=${name2%$numstr2}
		num2=10#${numstr2}

		[ "$suffix" == "$suffix2" -a "$prefix" == "$prefix2" ] && {
			if (( num2 == rangeto ))
			then
				return 1
			fi
			if (( num2 == rangeto+1 ))
			then
				let rangeto++
				continue;
			fi
		}

		# found a hole
		rangefromstring=$rangefrom
		if [ -z "$range" ]
		then
			while (( ${#rangefromstring} < width ))
			do
				rangefromstring="0$rangefromstring"
			done
#			range="["
		else
			range="$range,"
		fi
		if (( rangefrom == rangeto ))
		then
			range="$range$numstr"
		else
			range="$range$rangefromstring-$rangeto"
		fi
		if [ "$suffix" != "$suffix2" -o "$prefix" != "$prefix2" ]
		then
			[ "$range" != "$numstr" ] && range="[$range]"
			# found a 'big' hole!
			nlist="$nlist$prefix$range$suffix "
			range=""
		fi
		rangefrom=$num2
		rangeto=$num2
		suffix=$suffix2
		prefix=$prefix2
		num=$num2
		numstr=$numstr2
	done
	rangefromstring=$rangefrom
	if [ -z "$range" ]
	then
		while (( ${#rangefromstring} < width ))
		do
			rangefromstring="0$rangefromstring"
		done
#		range="["
	else
		range="$range,"
	fi
	if [ $rangefrom == $rangeto ]
	then
		range="$range$numstr"
	else
		range="$range$rangefromstring-$rangeto"
	fi
	[ "$range" != "$numstr" ] && range="[$range]"
	nlist="$nlist$prefix$range$suffix "
	echo $nlist
	return
}

function NameCompress()
{
	local -ir maxloops=5
	local -i loop=1
	local list
	local previouslist

#	previouslist=$(echo $* | tr ' ,' '\n' | sort -n | tr '\n' ' ')
	previouslist=$(echo $* |
		sed -e 's/,/\n/g' -e 's/ /\n/g' -e 's/\([0-9]\+\)/:\1:/g' |
		sort -t \: -n -k 1 -k 2 -k 3 -k 4 -k 5 |
		sed -e 's/://g' | tr '\n' ' '
		)
	[[ "$previouslist" =~ [^a-zA-Z0-9_\ ] ]] && {
		return 1
	}

	list=$(NameCompressLevel 0 $previouslist)
	while [ "$list" != "$previouslist" ]
	do
		previouslist=$list
		[[ "$list" =~ " "  ]]  &&
			list=$(NameCompressLevel $loop $previouslist) || break

		(( ++loop > maxloops )) && break
	done
	echo ${list//" "/","}
}

###=== fg functions end ===

#
# remove $1 from nodelist
#
function del_node()
{
    NODES=" ${NODES[*]} "
    NODES=(${NODES/" $1 "/" "})
}


#
# Just fetch SIGINT
#
function killcurrent
{
    echo kill $WAITFOR
}

#
# Wait until the next process ends and collect the exit code.
#
function ecollect
{
    ii=${#EXITCODES[*]}
    WAITFOR=${PIDS[$ii]}
    if [ "$VERBOSE" = 1 ];then
	echo "Wait for ${NODES[${#EXITCODES[*]}]} (pid ${PIDS[$ii]})"
    fi
    wait ${PIDS[$ii]}
    ec="$?"
    if [ "$ec" != "0" ]; then
	echo "Exit $ec" >> ${OUTPUTS[$ii]}
    fi
    EXITCODES=(${EXITCODES[*]} "$ec")
}

trap cleanup EXIT

CONFIG="$D_CONFIG"
CONFIG_D="$D_CONFIG_D"

#
# Parse commandline
#
optsource="Commandline"
prearg="-"
nopts=1
while [ $nopts != 0 ] ; do
    parse "$@"
    shift $nopts
done

#
# Read configuration
#
prearg=""
cmd_line_nodes="${#NODES[*]}"

if [ -f "${CONFIG}" ]; then
    line=0
    while read command opts; do
	line=$(( $line + 1 ))
	optsource="$CONFIG:$line"
	if [ ! -z "$command" ]; then
	    parse "$command" "$opts"
	fi
    done < "${CONFIG}"
fi

COMMAND="$*"

if [ x"$COMMAND" = x ];then
    if [ x"$SYNC" = x ]; then
	echo "Error: Missing command"
    else
	echo "Error: Missing filename"
    fi
    help
    exit 1
fi

if [ "${#NODES[*]}" = 0 ];then
    echo "Error: No nodes"
    help
    exit 1
fi

for((i = 0 ;i < ${#XNODES[*]} ;i++)); do
    del_node ${XNODES[$i]}
done


RCMD="${RCMD-$D_RCMD}"
MAXRCMD="${MAXRCMD-$D_MAXRCMD}"
DIFFCMD="${DIFFCMD-$D_DIFFCMD}"
AUTOCD="${AUTOCD-$D_AUTOCD}"

if [ "${SYNC}" = 1 ]; then
    FILELIST="$COMMAND"
    COMMAND="tar xvPf -";
    TARFILE=$(mktemp $TMPTEMPLATE)
    TMPFILES="$TMPFILES $TARFILE"
    echo "Prepare files for distribution:"
    tar cvPf "${TARFILE}" ${FILELIST}
    echo "Continue(y/n)?[n]"
    read c
    case "$c" in
	y|Y)
	;;
	*)
	    exit 1;
    esac
    INPUT="${TARFILE}"
else
    INPUT="/dev/null"
fi



if [ "$VERBOSE" = 1 ];then
cat <<EOF
CONFIG  ${D_CONFIG}
NODES   ${NODES[*]}
NODESSHORT $(NameCompress ${NODES[*]})
RCMD    $RCMD
COMMAND $COMMAND
EOF
fi

## Use specal syntax for mpiexec
if [ "$USE_MPIEXEC" == "TRUE" ] ; then
    nodes=${NODES[*]}
    $RCMD "$nodes" $COMMAND
    exit 0
fi


trap killcurrent SIGINT

#
# Start remote jobs
#
for ((i = 0; i < ${#NODES[*]} ; i++)); do
    host=${NODES[$i]}
    OUTFILE=$(mktemp $TMPTEMPLATE)
    TMPFILES="$TMPFILES $OUTFILE"
    OUTPUTS=(${OUTPUTS[*]} ${OUTFILE})
    < "${INPUT}" $RCMD "$host" "$AUTOCD$COMMAND" > $OUTFILE 2>&1 &
    PIDS=(${PIDS[*]} $!)
    if [ "$VERBOSE" = 1 ];then
	echo "$RCMD $host $COMMAND"
    fi
    if [ $(($i + 1)) -ge "$MAXRCMD" ]; then
	ecollect
    fi
done

#
# Wait for finish
#
for ((i = ${#EXITCODES[*]}; i < ${#NODES[*]} ; i++)); do
    ecollect
done

#
# Merge outputs
#
for ((i = 0; i < ${#NODES[*]} ; i++)); do
    hosts=${NODES[$i]}
    if [ "${DISPLAYED[$i]}" != "1" ]; then
	# search for equal outputs
	for ((ii = $i + 1; ii < ${#NODES[*]} ; ii++)); do
	    if [ "${DISPLAYED[$ii]}" != "1" ]; then
      #	    echo Compare ${OUTPUTS[$i]} ${OUTPUTS[$ii]}
		if ${DIFFCMD} ${OUTPUTS[$i]} ${OUTPUTS[$ii]} > /dev/null; then
		    hosts="$hosts ${NODES[$ii]}"
		    DISPLAYED[$ii]="1";
		fi
	    fi
	done
	echo "=== $(NameCompress $hosts)"
	cat ${OUTPUTS[$i]}
    fi
done
