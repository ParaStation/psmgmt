/*
 * ParaStation
 *
 * Copyright (C) 2014 ParTec Cluster Competence Center GmbH, Munich
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined in the file LICENSE.QPL included in the packaging of this
 * file.
 */
/**
 * $Id$
 *
 * \author
 * Michael Rauh <rauh@par-tec.com>
 *
 */

#ifndef __PS_SLURM_COMM
#define __PS_SLURM_COMM

#include "psslurmjob.h"
#include "plugincomm.h"

typedef enum {
    REQUEST_NODE_REGISTRATION_STATUS = 1001,
    MESSAGE_NODE_REGISTRATION_STATUS,
    REQUEST_RECONFIGURE,
    RESPONSE_RECONFIGURE,
    REQUEST_SHUTDOWN,
    REQUEST_SHUTDOWN_IMMEDIATE,
    RESPONSE_SHUTDOWN,
    REQUEST_PING,
    REQUEST_CONTROL,
    REQUEST_SET_DEBUG_LEVEL,
    REQUEST_HEALTH_CHECK,
    REQUEST_TAKEOVER,
    REQUEST_SET_SCHEDLOG_LEVEL,
    REQUEST_SET_DEBUG_FLAGS,
    REQUEST_REBOOT_NODES,
    RESPONSE_PING_SLURMD,
    REQUEST_ACCT_GATHER_UPDATE,
    RESPONSE_ACCT_GATHER_UPDATE,
    REQUEST_ACCT_GATHER_ENERGY,
    RESPONSE_ACCT_GATHER_ENERGY,

    REQUEST_BUILD_INFO = 2001,
    RESPONSE_BUILD_INFO,
    REQUEST_JOB_INFO,
    RESPONSE_JOB_INFO,
    REQUEST_JOB_STEP_INFO,
    RESPONSE_JOB_STEP_INFO,
    REQUEST_NODE_INFO,
    RESPONSE_NODE_INFO,
    REQUEST_PARTITION_INFO,
    RESPONSE_PARTITION_INFO,
    REQUEST_ACCTING_INFO,
    RESPONSE_ACCOUNTING_INFO,
    REQUEST_JOB_ID,
    RESPONSE_JOB_ID,
    REQUEST_BLOCK_INFO,
    RESPONSE_BLOCK_INFO,
    REQUEST_TRIGGER_SET,
    REQUEST_TRIGGER_GET,
    REQUEST_TRIGGER_CLEAR,
    RESPONSE_TRIGGER_GET,
    REQUEST_JOB_INFO_SINGLE,
    REQUEST_SHARE_INFO,
    RESPONSE_SHARE_INFO,
    REQUEST_RESERVATION_INFO,
    RESPONSE_RESERVATION_INFO,
    REQUEST_PRIORITY_FACTORS,
    RESPONSE_PRIORITY_FACTORS,
    REQUEST_TOPO_INFO,
    RESPONSE_TOPO_INFO,
    REQUEST_TRIGGER_PULL,
    REQUEST_FRONT_END_INFO,
    RESPONSE_FRONT_END_INFO,
    REQUEST_SPANK_ENVIRONMENT,
    RESPONCE_SPANK_ENVIRONMENT,
    REQUEST_STATS_INFO,
    RESPONSE_STATS_INFO,
    REQUEST_STATS_RESET,
    RESPONSE_STATS_RESET,
    REQUEST_JOB_USER_INFO,
    REQUEST_NODE_INFO_SINGLE,

    REQUEST_UPDATE_JOB = 3001,
    REQUEST_UPDATE_NODE,
    REQUEST_CREATE_PARTITION,
    REQUEST_DELETE_PARTITION,
    REQUEST_UPDATE_PARTITION,
    REQUEST_CREATE_RESERVATION,
    RESPONSE_CREATE_RESERVATION,
    REQUEST_DELETE_RESERVATION,
    REQUEST_UPDATE_RESERVATION,
    REQUEST_UPDATE_BLOCK,
    REQUEST_UPDATE_FRONT_END,

    REQUEST_RESOURCE_ALLOCATION = 4001,
    RESPONSE_RESOURCE_ALLOCATION,
    REQUEST_SUBMIT_BATCH_JOB,
    RESPONSE_SUBMIT_BATCH_JOB,
    REQUEST_BATCH_JOB_LAUNCH,
    REQUEST_CANCEL_JOB,
    RESPONSE_CANCEL_JOB,
    REQUEST_JOB_RESOURCE,
    RESPONSE_JOB_RESOURCE,
    REQUEST_JOB_ATTACH,
    RESPONSE_JOB_ATTACH,
    REQUEST_JOB_WILL_RUN,
    RESPONSE_JOB_WILL_RUN,
    REQUEST_JOB_ALLOCATION_INFO,
    RESPONSE_JOB_ALLOCATION_INFO,
    REQUEST_JOB_ALLOCATION_INFO_LITE,
    RESPONSE_JOB_ALLOCATION_INFO_LITE,
    REQUEST_UPDATE_JOB_TIME,
    REQUEST_JOB_READY,
    RESPONSE_JOB_READY,
    REQUEST_JOB_END_TIME,
    REQUEST_JOB_NOTIFY,
    REQUEST_JOB_SBCAST_CRED,
    RESPONSE_JOB_SBCAST_CRED,

    REQUEST_JOB_STEP_CREATE = 5001,
    RESPONSE_JOB_STEP_CREATE,
    REQUEST_RUN_JOB_STEP,
    RESPONSE_RUN_JOB_STEP,
    REQUEST_CANCEL_JOB_STEP,
    RESPONSE_CANCEL_JOB_STEP,
    REQUEST_UPDATE_JOB_STEP,
    DEFUNCT_RESPONSE_COMPLETE_JOB_STEP, /* DEFUNCT */
    REQUEST_CHECKPOINT,
    RESPONSE_CHECKPOINT,
    REQUEST_CHECKPOINT_COMP,
    REQUEST_CHECKPOINT_TASK_COMP,
    RESPONSE_CHECKPOINT_COMP,
    REQUEST_SUSPEND,
    RESPONSE_SUSPEND,
    REQUEST_STEP_COMPLETE,
    REQUEST_COMPLETE_JOB_ALLOCATION,
    REQUEST_COMPLETE_BATCH_SCRIPT,
    REQUEST_JOB_STEP_STAT,
    RESPONSE_JOB_STEP_STAT,
    REQUEST_STEP_LAYOUT,
    RESPONSE_STEP_LAYOUT,
    REQUEST_JOB_REQUEUE,
    REQUEST_DAEMON_STATUS,
    RESPONSE_SLURMD_STATUS,
    RESPONSE_SLURMCTLD_STATUS,
    REQUEST_JOB_STEP_PIDS,
    RESPONSE_JOB_STEP_PIDS,
    REQUEST_FORWARD_DATA,
    REQUEST_COMPLETE_BATCH_JOB,
    REQUEST_SUSPEND_INT,

    REQUEST_LAUNCH_TASKS = 6001,
    RESPONSE_LAUNCH_TASKS,
    MESSAGE_TASK_EXIT,
    REQUEST_SIGNAL_TASKS,
    REQUEST_CHECKPOINT_TASKS,
    REQUEST_TERMINATE_TASKS,
    REQUEST_REATTACH_TASKS,
    RESPONSE_REATTACH_TASKS,
    REQUEST_KILL_TIMELIMIT,
    REQUEST_SIGNAL_JOB,
    REQUEST_TERMINATE_JOB,
    MESSAGE_EPILOG_COMPLETE,
    REQUEST_ABORT_JOB,      /* job shouldn't be running, kill it without
			     * job/step/task complete responses */
    REQUEST_FILE_BCAST,
    TASK_USER_MANAGED_IO_STREAM,
    REQUEST_KILL_PREEMPTED,

    REQUEST_LAUNCH_PROLOG,
    REQUEST_COMPLETE_PROLOG,
    RESPONSE_PROLOG_EXECUTING,

    SRUN_PING = 7001,
    SRUN_TIMEOUT,
    SRUN_NODE_FAIL,
    SRUN_JOB_COMPLETE,
    SRUN_USER_MSG,
    SRUN_EXEC,
    SRUN_STEP_MISSING,
    SRUN_REQUEST_SUSPEND,
    SRUN_STEP_SIGNAL,       /* for launch plugins aprun, poe and runjob,
			     * srun forwards signal to the launch command */

    PMI_KVS_PUT_REQ = 7201,
    PMI_KVS_PUT_RESP,
    PMI_KVS_GET_REQ,
    PMI_KVS_GET_RESP,

    RESPONSE_SLURM_RC = 8001,

    RESPONSE_FORWARD_FAILED = 9001,

    ACCOUNTING_UPDATE_MSG = 10001,
    ACCOUNTING_FIRST_REG,
    ACCOUNTING_REGISTER_CTLD,

} slurm_msg_type_t;

typedef struct {
    uint16_t version;
    uint16_t flags;
    uint16_t type;
    uint32_t bodyLen;
    uint16_t forward;
    uint16_t returnList;
    uint32_t addr;
    uint16_t port;
    uid_t uid;
    gid_t gid;
} Slurm_msg_header_t;

int openSlurmdSocket(int port);
int sendSlurmMsg(int sock, slurm_msg_type_t type, PS_DataBuffer_t *body,
		    void *sockData);
int readSlurmMessage(int sock, char **buffer);
const char *msgType2String(int type);
#define getBitString(ptr, bits) __getBitString(ptr, bits, __func__, __LINE__)
void __getBitString(char **ptr, bitstr_t **bitStr, const char *func,
				const int line);
int tcpConnect(char *addr, char *port);
void getSockInfo(int socket, uint32_t *addr, uint16_t *port);

int srunOpenControlConnection(Step_t *step);
int srunOpenIOConnection(Step_t *step);
int srunOpenPTY(Step_t *step);
int srunSendIO(uint16_t type, Step_t *step, char *buf, uint32_t bufLen);
int srunSendMsg(int sock, Step_t *step, slurm_msg_type_t type,
		PS_DataBuffer_t *body);
#endif
