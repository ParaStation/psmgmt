<chapter id="mpi">
  <title>Using MPI</title>
  <para>
    The aim of this chapter is to explain how to compile and link MPI
    applications using the adapted version of <ulink
      url="http://www.unix.mcs.anl.gov/mpi/mpich">MPIch</ulink> comming with
    &ps;. Within this chapter it is assumed that this version of MPI is
    installed in the default location, i.e.
    <filename>/opt/parastion/mpich</filename>. If this is not the case please
    refer to the section <quote>Installation of MPIch</quote> within the <ulink
      url="../adminguide/index.html" type="dontshow">&ps; Administrators
      Guide</ulink> in order to setup things correctly.
  </para>
  <para>
    Furthermore it is assumed that the directory containing all MPIch
    executables, i.e. <filename>/opt/parastation/mpich/bin</filename> is
    contained in the users <envar>PATH</envar> environment variable.
  </para>
  <para>
    This chapter is not intended to be a tutorial on how to use the MPI message
    passing interface. It is assumed that the reader knows how to write MPI
    applications and how to compile programs in general on the platform &ps; is
    running on. If you don't know about MPI yet the <ulink
      url="http://www-unix.mcs.anl.gov/mpi/">MPI homepage</ulink> is a good
    starting point.
  </para>
  <section>
    <title>Building MPI applications</title>
    <para>
      Within this section it is assumed to have a working C source code stored
      in <filename>prog.c</filename> which uses MPI to send messages between
      the different processes. In order to create an executable from this
      source code, all that has to be done is:
    </para>
    <programlisting>	mpicc prog.c -o prog</programlisting>
    <para>
      This will create the executable <filename>prog</filename> from the source
      code. Notice that the header file <filename>mpi.h</filename> and the
      libraries needed to link the programs are found automatically.
      Furthermore you don't have to deal with the names of the libraries needed
      for linking. The actual MPI library and further libraries containing the
      low level communication calls are also linked automatically.
    </para>
    <para>
      If your code is scattered to various source files, building is as
      easy as in the example above. First compile all the source files using
    </para>
    <programlisting>	mpicc -c *.c</programlisting>
    <para>
      and afterwards link everything together:
    </para>
    <programlisting>	mpicc *.o -o prog</programlisting>
    <para>
      The building of Fortran 77, Fortran 90 or C++ codes is very similar. Just
      replace the <command>mpicc</command> by <command>mpif77</command>,
      <command>mpif90</command> and <command>mpiCC</command> respectively.
    </para>
  </section>
  <section>
    <title>Starting MPI applications</title>
    <para>
      In order to start a MPI application build as described in the last
      section, <command>mpirun</command> has to be used. If you want to start
      the executable <filename>prog</filename> on 8 nodes,
    </para>
    <programlisting>	mpirun -np 8 prog</programlisting>
    <para>
      has to be executed. Of course further options to
      <filename>prog</filename> may be appended to this line.
    </para>
    <para>
      All what has been said about spawning and input/output redirection in
      <xref linkend="startup"/> is totally true for MPI applications linked
      against &ps;. I.e. all the environment variables discussed in
      <xref linkend="environment"/> can be used to steer the distribution of
      processes within the cluster.
    </para>
  </section>
  <section>
    <title>Environment steering MPIch</title>
    <para>
      Within this section the environment variables that may be used in order
      to modify the behavior of MPI are discussed. Be aware of the fact that
      this does not include the environment variables steering the spawning
      process, which are covered within <xref linkend="environment"/>.
    </para>
    <para>
      Most of the described environment variables are also discussed in the
      manual pages comming with MPIch. The only exception is
      <envar>MPID_PSP_MAXSMALLMSG</envar>. This will steer the communication
      layer used by &ps;, which is not part of the standard MPIch
      distribution but an extension provided by ParTec.
    </para>
    <para>
      The <command>mpicc</command> wrapper script, calling the actual C
      compiler, is controlled by two environment variables:
    </para>
    <variablelist>
      <varlistentry>
	<term><envar>MPICH_CC</envar></term>
	<listitem>
	  <para>This will set the actual C compiler used to compile the code.
	    The default compiler used usually is the GNU C compiler <ulink
	      url="http://gcc.gnu.org">gcc</ulink>. Use this variable to
	    overwrite the default setting.
	  </para>
	  <para>
	    In order to use a compiler different from the default, it has to be
	    guaranteed that the produced object files are compatible to the
	    <command>gcc</command> ones, since the MPI and &ps; libraries are
	    produced with this compiler. This is normally no problem, since
	    object code produced by most compilers is compatible to the
	    <command>gcc</command> stuff (or vice versa).
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><envar>MPICH_CLINKER</envar></term>
	<listitem>
	  <para>This will set the actual C linker used to link the code. The
	    default linker used ususally is the GNU C compiler <ulink
	      url="http://gcc.gnu.org">gcc</ulink>.
	  </para>
	  <para>
	    In order to use a linker different from the default, it has to be
	    guaranteed that the linked object files are compatible to the
	    <command>gcc</command> ones, since the MPI and &ps;
	    libraries are produced with this compiler.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>
      The same mechanism works for the C++ compiler used by the correspondig
      <command>mpiCC</command> wrapper script:
    </para>
    <variablelist>
      <varlistentry>
	<term><envar>MPICH_CCC</envar></term>
	<listitem>
	  <para>This will set the actual C++ compiler used to compile the code.
	    The default compiler used usually is the GNU C++ compiler <ulink
	      url="http://gcc.gnu.org">g++</ulink>. Use this variable to
	    overwrite the default setting.
	  </para>
	  <para>
	    In order to use a compiler different from the default, it has to be
	    guaranteed that the produced object files are compatible to the
	    <command>g++</command> ones, since the MPI and &ps;
	    libraries are produced with this compiler. This is normally no
	    problem, since object code produced by most compilers is compatible
	    to the <command>gcc</command> stuff (or vice versa).
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><envar>MPICH_CCLINKER</envar></term>
	<listitem>
	  <para>This will set the actual C++ linker used to link the code. The
	    default linker used ususally is the GNU C++ compiler <ulink
	      url="http://gcc.gnu.org">g++</ulink>.
	  </para>
	  <para>
	    In order to use a linker different from the default, it has to be
	    guaranteed that the linked object files are compatible to the
	    <command>g++</command> ones, since the MPI and &ps;
	    libraries are produced with this compiler.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>
      The <command>mpif77</command> wrapper script, calling the actual Fortan
      77 compiler, is also controlled by two environment variables:
    </para>
    <variablelist>
      <varlistentry>
	<term><envar>MPICH_F77</envar></term>
	<listitem>
	  <para>This will set the actual Fortran 77 compiler used to compile
	    the code. The default compiler on i386 platforms is the GNU Fortran
	    compiler <ulink url="http://gcc.gnu.org">g77</ulink>, an
	    alternative version of the wrapper script called
	    <command>mpif77-ifc</command> will use the Intel Fortran compiler
	    <ulink
	      url="http://developer.intel.com/software/products/compilers/f60l">ifc</ulink>. 
	    On the alpha platform the Compaq Fortran compiler <ulink
	      url="http://www.compaq.com/fortran/linux/">fort</ulink> is used.
	    Use this variable to overwrite the default setting.
	  </para>
	  <para>
	    In order to use a compiler different from the default, it has to be
	    guaranteed that the produced object files are compatible to the
	    default ones, since the MPI and &ps; libraries are produced
	    with this compiler. Different to C compilers this might be a major
	    problem for Fortran build.
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><envar>MPICH_FLINKER</envar></term>
	<listitem>
	  <para>This will set the actual Fortran 77 linker used to link the
	    code. The default linker on i386 platforms is the GNU Fortran 77
	    compiler <ulink url="http://gcc.gnu.org">g77</ulink> or the Intel
	    Fortran compiler <ulink
	      url="http://developer.intel.com/software/products/compilers/f60l">ifc</ulink> 
	    within the alternative <command>mpif77-ifc</command> script, on the
	    alpha platform it is the Compaq Fortran compiler <ulink
	      url="http://www.compaq.com/fortran/linux/">fort</ulink>.
	  </para>
	  <para>
	    In order to use a linker different from the default, it has to be
	    guaranteed that the linked object files are compatible to the
	    standard ones, since the MPI and &ps; libraries are produced
	    with this compiler.
	  </para>
	  <note>
	    <para>
	      Notice that the actual environment variable to use is
	      <envar>MPICH_FLINKER</envar> and not
	      <envar>MPICH_F77LINKER</envar> as written in the <citerefentry>
		<refentrytitle>mpif77</refentrytitle>
		<manvolnum>1</manvolnum>
	      </citerefentry> manual page.
	    </para>
	  </note>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>
      Last but not least also the <command>mpif90</command> wrapper script can
      be controlled by this kind of mechanism. The corresponding environment
      variables are:
    </para>
    <variablelist>
      <varlistentry>
	<term><envar>MPICH_F90</envar></term>
	<listitem>
	  <para>This will set the actual Fortran 90 compiler used to compile
	    the code. The default compiler on the i386 platform is the Intel
	    Fortran 90 compiler <ulink
	      url="http://developer.intel.com/software/products/compilers/f60l">ifc</ulink>, 
	    on the alpha platform it is the Compaq Fortran compiler <ulink
	      url="http://www.compaq.com/fortran/linux/">fort</ulink>. Use this
	    variable to overwrite the default setting.
	  </para>
	  <para>
	    In order to use a compiler different from the default, it has to be
	    guaranteed that the produced object files are compatible to the
	    standard ones, since the MPI and &ps; libraries are produced
	    with this compiler.
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><envar>MPICH_F90LINKER</envar></term>
	<listitem>
	  <para>This will set the actual linker used to link Fortran 90 code.
	    The default linker on i386 platforms is the  Intel Fortran 90
	    compiler <ulink
	      url="http://developer.intel.com/software/products/compilers/f60l">ifc</ulink>, 
	    on alpha platforms the Compaq Fortran compiler <ulink
	      url="http://www.compaq.com/fortran/linux/">fort</ulink> is used.
	  </para>
	  <para>
	    In order to use a linker different from the default, it has to be
	    guaranteed that the linked object files are compatible to the
	    standard ones, since the MPI and &ps; libraries are produced
	    with this compiler.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>
      Always remember to replace both, compiler <emphasis
	role="bold">and</emphasis> linker, in order to produce better optimized
      executables.
    </para>
    <para>
      The last environment variable discussed in this section will steer the
      communication layer in between the actual MPIch library and &ps;s PSPort
      library used to really do the communication:
    </para>
    <variablelist>
      <varlistentry>
	<term>MPID_PSP_MAXSMALLMSG</term>
	<listitem>
	  <para>The ADI supplied by &ps; which is used within MPIch to actually
	    send data to a different node uses two distinct protocols depending
	    on the length of the message to send.
	  </para>
	  <para>
	    For long messages a so called rendezvous protocol is used to send,
	    small messages are handled with a simpler protocol. Use this
	    environment variable to set the length of the largest message (in
	    bytes) which is sent without rendezvous.
	  </para>
	  <para>
	    The default value used when <envar>MPID_PSP_MAXSMALLMSG</envar> is
	    not given is 32768.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>
  </section>
</chapter>
  <!-- Keep this comment at the end of the file
  Local variables:
  mode: xml
  sgml-omittag:nil
  sgml-shorttag:nil
  sgml-namecase-general:nil
  sgml-general-insert-case:lower
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("userguide.xml" "book" "book" ("title" "bookinfo"))
  sgml-exposed-tags:nil
  sgml-local-catalogs:nil
  sgml-local-ecat-files:nil
  End:
  -->
