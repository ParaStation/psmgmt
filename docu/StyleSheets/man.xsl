<?xml version='1.0'?>
<!-- vim:set sts=2 shiftwidth=2 syntax=sgml: -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version='1.0'>

  <xsl:import href="/usr/share/sgml/docbook/xsl-stylesheets/manpages/docbook.xsl"/>


  <!-- ************** Modifications to common/common.xsl *********** -->
  <xsl:strip-space elements="term"/>


  <!-- ************** Modifications to manpages/db2man.xsl *********** -->
  <!-- The modified refentry -->
  <xsl:template match="refentry">
    <xsl:variable name="section" select="refmeta/manvolnum"/>
    <xsl:variable name="name" select="refnamediv/refname[1]"/>

    <!-- standard man page width is 64 chars; 6 chars needed for the two
         (x) volume numbers, and 2 spaces, leaves 56 -->
    <xsl:variable name="twidth" select="(56 - string-length(refmeta/refentrytitle)) div 2"/>

    <xsl:variable name="reftitle" 
      select="substring(refmeta/refentrytitle, 1, $twidth)"/>

    <xsl:variable name="title">
      <xsl:choose>
	<xsl:when test="refentryinfo/title">
	  <xsl:value-of select="refentryinfo/title"/>
	</xsl:when>
	<xsl:when test="../referenceinfo/title">
	  <xsl:value-of select="../referenceinfo/title"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:variable name="date">
      <xsl:choose>
	<xsl:when test="refentryinfo/date">
	  <xsl:value-of select="refentryinfo/date"/>
	</xsl:when>
	<xsl:when test="../referenceinfo/date">
	  <xsl:value-of select="../referenceinfo/date"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:variable name="productname">
      <xsl:choose>
	<xsl:when test="refentryinfo/productname">
	  <xsl:value-of select="refentryinfo/productname"/>
	</xsl:when>
	<xsl:when test="../referenceinfo/productname">
	  <xsl:value-of select="../referenceinfo/productname"/>
	</xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:call-template name="write.text.chunk">
      <xsl:with-param name="filename"
		      select="concat('man', $section, '/', normalize-space($name), '.', $section)"/>
      <xsl:with-param name="content">
	<xsl:text>.\"Generated by man/docbook.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.\" PP
\fB\\$1\fR
.\" PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "</xsl:text>
	<xsl:value-of select="translate($reftitle,'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
	<xsl:text>" </xsl:text>
	<xsl:value-of select="refmeta/manvolnum[1]"/>
	<xsl:text> "</xsl:text>
	<xsl:value-of select="normalize-space($date)"/>
	<xsl:text>" "</xsl:text>
	<xsl:value-of select="normalize-space($productname)"/>
	<xsl:text>" "</xsl:text>
	<xsl:value-of select="$title"/>
	<xsl:text>"
</xsl:text>
	<xsl:apply-templates/>
	<xsl:text>&#10;</xsl:text>

	<!-- Author section -->
	<xsl:choose>
	  <xsl:when test="refentryinfo//author">
	    <xsl:apply-templates select="refentryinfo" mode="authorsect"/>
	  </xsl:when>
	  <xsl:when test="/book/bookinfo//author">
	    <xsl:apply-templates select="/book/bookinfo" mode="authorsect"/>
	  </xsl:when>
	  <xsl:when test="/article/articleinfo//author">
	    <xsl:apply-templates select="/article/articleinfo" mode="authorsect"/>
	  </xsl:when>
	</xsl:choose>

      </xsl:with-param>
    </xsl:call-template>
    <!-- Now generate stub include pages for every page documented in
         this refentry (except the page itself) -->
    <xsl:for-each select="refnamediv/refname">
      <xsl:if test=". != $name">
	<xsl:call-template name="write.text.chunk">
	  <xsl:with-param name="filename"
	    select="concat('man', $section, '/', normalize-space(.), '.', $section)"/>
	  <xsl:with-param name="content" select="concat('.so man', $section, '/', $name, '.', $section, '&#10;')"/>
	</xsl:call-template>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <!-- Select this version of filename, suppress the error -->
  <xsl:template match="filename">
    <xsl:apply-templates mode="italic" select="."/>
  </xsl:template>

  <xsl:template match="varlistentry/listitem|glossdef">
    <xsl:text>&#10;.RS&#10;</xsl:text>
    <xsl:apply-templates mode="list"/>
    <xsl:text>.RE&#10;</xsl:text>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="para">
    <xsl:text>.PP&#10;</xsl:text>
    <xsl:for-each select="node()">
      <xsl:choose>
	<xsl:when test="self::screen|self::programlisting|self::itemizedlist|self::orderedlist|self::variablelist">
	  <xsl:text>&#10;</xsl:text>
	  <xsl:apply-templates/>
	</xsl:when>
	<xsl:when test="self::text()">
	  <xsl:if test="starts-with(translate(.,'&#10;',' '), ' ') and
	                preceding-sibling::node()[name(.)!='']">
	    <xsl:text> </xsl:text>
	  </xsl:if>
	  <xsl:variable name="content">
	    <xsl:apply-templates select="."/>
	  </xsl:variable>
	  <xsl:value-of select="normalize-space($content)"/>
	  <xsl:if
	    test="translate(substring(., string-length(.), 1),'&#10;',' ')=' '
	          and following-sibling::node()[name(.)!='']">
	    <xsl:text> </xsl:text>
	  </xsl:if>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:variable name="content">
	    <xsl:apply-templates select="."/>
	  </xsl:variable>
	  <xsl:value-of select="normalize-space($content)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
    <xsl:text>&#10;</xsl:text>
  </xsl:template>

  <!-- Always print ':' , remove extra newline -->
  <xsl:template match="caution|important|note|tip|warning">
    <xsl:text>&#10;.RS&#10;.Sh "</xsl:text>
    <!-- capitalize word -->
    <xsl:value-of
      select="translate (substring (name(.), 1, 1), 'cintw', 'CINTW')" />
    <xsl:value-of select="substring (name(), 2)" />
    <xsl:text>:</xsl:text>
    <xsl:if test="title">
      <xsl:text> </xsl:text>
      <xsl:value-of select="title[1]"/>
    </xsl:if>
    <xsl:text>"&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>.RE&#10;</xsl:text>
  </xsl:template>

  <!-- ************** Modifications to manpages/lists.xsl *********** -->
  <!-- There are also caution/important/note/tip/warning entries in list! -->
  <xsl:template match="caution|important|note|tip|warning" mode="list">
    <xsl:apply-templates select="."/>
  </xsl:template> 

  <!-- Remove extra newline -->
  <xsl:template match="varlistentry|glossentry">
    <xsl:text>.TP&#10;</xsl:text>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="variablelist|glosslist" mode="list">
    <xsl:apply-templates/>
    <xsl:text>&#10;</xsl:text>
  </xsl:template>

  <!-- Much simpler term entries within varlist -->
  <xsl:template match="varlistentry/term">
    <xsl:apply-templates/>
    <xsl:text>, </xsl:text>
  </xsl:template>
  <xsl:template match="varlistentry/term[position()=last()]" priority="2">
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="itemizedlist|orderedlist|procedure">
    <xsl:text>.TP 3&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>.LP&#10;</xsl:text>
  </xsl:template>

  <!-- ************** Modifications to manpages/synop.xsl *********** -->
  <!-- Put repeat string after group -->
  <xsl:template match="group|arg">
    <xsl:variable name="choice" select="@choice"/>
    <xsl:variable name="rep" select="@rep"/>
    <xsl:variable name="sepchar">
      <xsl:choose>
	<xsl:when test="ancestor-or-self::*/@sepchar">
	  <xsl:value-of select="ancestor-or-self::*/@sepchar"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text> </xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="position()>1"><xsl:value-of select="$sepchar"/></xsl:if>
    <xsl:choose>
      <xsl:when test="$choice='plain'">
	<!-- do nothing -->
      </xsl:when>
      <xsl:when test="$choice='req'">
	<xsl:value-of select="$arg.choice.req.open.str"/>
      </xsl:when>
      <xsl:when test="$choice='opt'">
	<xsl:value-of select="$arg.choice.opt.open.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.choice.def.open.str"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:variable name="arg">
      <xsl:apply-templates/>
    </xsl:variable>
    <xsl:value-of select="normalize-space($arg)"/>
    <xsl:choose>
      <xsl:when test="$choice='plain'">
	<xsl:if test='arg'>
	  <xsl:value-of select="$arg.choice.plain.close.str"/>
	</xsl:if>
      </xsl:when>
      <xsl:when test="$choice='req'">
	<xsl:value-of select="$arg.choice.req.close.str"/>
      </xsl:when>
      <xsl:when test="$choice='opt'">
	<xsl:value-of select="$arg.choice.opt.close.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.choice.def.close.str"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
      <xsl:when test="$rep='repeat'">
	<xsl:value-of select="$arg.rep.repeat.str"/>
      </xsl:when>
      <xsl:when test="$rep='norepeat'">
	<xsl:value-of select="$arg.rep.norepeat.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.rep.def.str"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Pass choice and rep arguments thru -->
  <xsl:template match="group/arg">
    <xsl:variable name="choice" select="@choice"/>
    <xsl:variable name="rep" select="@rep"/>
    <xsl:if test="position()>1"><xsl:value-of select="$arg.or.sep"/></xsl:if>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Pass width to the next stage of wrap-cmd -->
  <xsl:template name="wrap-cmd">
    <xsl:param name="indent" select="''"/>
    <xsl:param name="text" select="''"/>
    <xsl:param name="allow" select="75"/>
    <xsl:param name="width" select="$allow - string-length($indent)"/>
    <xsl:variable name="total" select="string-length($text)"/>
    <xsl:variable name="split"
      select="substring($text,$width+1,$total - $width)"/>
    <xsl:variable name="fragment" select="substring-before($split,' ')"/>
    <xsl:variable name="line">
      <xsl:value-of select="substring($text,1,$width)"/>
      <xsl:choose>
	<xsl:when test="$fragment!=''">
	  <xsl:value-of select="$fragment"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:choose>
	    <xsl:when test="10 > string-length($split)">
	      <xsl:value-of select="$split"/>
	    </xsl:when>
	  </xsl:choose>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$split=''">
	<xsl:value-of select="$line"/>
      </xsl:when>
      <xsl:when test="$line=concat(substring($text,1,$width),$split)">
	<xsl:value-of select="$line"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$line"/>
	<xsl:text>&#10;</xsl:text>
	<!-- <xsl:value-of select="$indent"/> -->
	<xsl:variable name="done" select="string-length($line)"/>
	<xsl:variable name="remaining" select="$total - $done + 1"/>
	<xsl:call-template name="wrap-cmd">
	  <xsl:with-param name="indent" select="$indent"/>
	  <xsl:with-param name="text"
	    select="substring($text,1+$done,$remaining)"/>
	  <xsl:with-param name="width" select="$width"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Do smarter formatting on cmdsynopsis entries -->
  <!-- Therefor we have to distinct between position()=1 and rest -->
  <xsl:template match="cmdsynopsis[position()=1]" priority="2">
    <xsl:text>.nf&#10;</xsl:text>
    <xsl:choose>
      <xsl:when test=".//sbr">
	<!-- The author has put explicit formatting hints in for us. -->
	<xsl:apply-templates/>
      </xsl:when>
      <xsl:otherwise>
	<!-- Try to do some smart formatting. -->
	<xsl:variable name="cmdsynopsis">
	  <xsl:apply-templates/>
	</xsl:variable>
	<xsl:variable name="cmd" select="command"/>
	<xsl:variable name="indent"
	  select="translate($cmd,$cmd,'                         ')"/>
	<xsl:text>\fB</xsl:text>
	<xsl:value-of select="$cmd"/><xsl:text>\fR</xsl:text>
	<xsl:call-template name="wrap-cmd">
	  <xsl:with-param name="indent" select="$indent"/>
	  <xsl:with-param name="text"
	    select="substring-after($cmdsynopsis,$cmd)"/>
	  <xsl:with-param name="allow" select="57"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#10;.fi&#10;</xsl:text>
  </xsl:template>

  <xsl:template match="cmdsynopsis">
    <xsl:text>.TP&#10;.nf&#10;</xsl:text>
    <xsl:choose>
      <xsl:when test=".//sbr">
	<!-- The author has put explicit formatting hints in for us. -->
	<xsl:apply-templates/>
      </xsl:when>
      <xsl:otherwise>
	<!-- Try to do some smart formatting. -->
	<xsl:variable name="cmdsynopsis">
	  <xsl:apply-templates/>
	</xsl:variable>
	<xsl:variable name="cmd" select="command"/>
	<xsl:variable name="indent"
	  select="translate($cmd,$cmd,'                         ')"/>
	<xsl:text>\fB</xsl:text>
	<xsl:value-of select="$cmd"/><xsl:text>\fR</xsl:text>
	<xsl:call-template name="wrap-cmd">
	  <xsl:with-param name="indent" select="$indent"/>
	  <xsl:with-param name="text"
	    select="substring-after($cmdsynopsis,$cmd)"/>
	  <xsl:with-param name="allow" select="57"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#10;.fi&#10;</xsl:text>
  </xsl:template>

  <xsl:template match="xref">
    <xsl:variable name="targets" select="id(@linkend)"/>
    <xsl:variable name="target" select="$targets[1]"/>
    <xsl:variable name="type" select="local-name($target)"/>

    <xsl:choose>
      <xsl:when test="$type=''">
	<xsl:message>
	  <xsl:text>xref to nonexistent id </xsl:text>
	  <xsl:value-of select="@linkend"/>
	</xsl:message>
      </xsl:when>

      <xsl:when test="$type='refentry'">
	<xsl:call-template name="do-citerefentry">
	  <xsl:with-param name="refentrytitle"
	    select="$target/refmeta/refentrytitle[1]"/>
	  <xsl:with-param name="manvolnum"
	    select="$target/refmeta/manvolnum"/>
	</xsl:call-template>
      </xsl:when>

      <xsl:when test="$type='refname'">
	<xsl:call-template name="do-citerefentry">
	  <xsl:with-param name="refentrytitle" select="$target"/>
	  <xsl:with-param name="manvolnum"
	    select="$target/../../refmeta/manvolnum"/>
	</xsl:call-template>
      </xsl:when>

      <xsl:when test="$type='book'">
	<xsl:text>'</xsl:text>
	<xsl:apply-templates mode="bold" select="$target/titleabbrev"/>
	<xsl:text>'</xsl:text>
      </xsl:when>

      <xsl:when test="$type='section'">
	<xsl:text>the section '</xsl:text>
	<xsl:apply-templates mode="bold" select="$target/title"/>
	<xsl:text>'</xsl:text>
      </xsl:when>

      <xsl:when test="$type='glossentry'">
	<xsl:value-of select="$target/glossterm"/>
      </xsl:when>

      <xsl:otherwise>
	<xsl:text>[xref to </xsl:text>
	<xsl:value-of select="$type"/>
	<xsl:text>]</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="emphasis">
    <xsl:choose>
      <xsl:when test="@role = 'bold'">
	<xsl:text>\fB</xsl:text>
      	<xsl:apply-templates/>
	<xsl:text>\fR</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

</xsl:stylesheet>
