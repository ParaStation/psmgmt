<?xml version='1.0'?>
<!-- vim:set sts=2 shiftwidth=2 syntax=sgml: -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version='1.0'>

  <xsl:import href="/usr/share/sgml/docbook/docbook-xsl-stylesheets-1.53.0/manpages/db2man.xsl"/>


  <!-- ************** Modifications to common/common.xsl *********** -->
  <xsl:strip-space elements="term"/>


  <!-- ************** Modifications to manpages/db2man.xsl *********** -->
  <!-- The modified refentry -->
  <xsl:template match="refentry">
    <xsl:variable name="section" select="refmeta/manvolnum"/>
    <xsl:variable name="name" select="refnamediv/refname[1]"/>

    <xsl:call-template name="write.text.chunk">
      <xsl:with-param name="filename"
	select="concat(normalize-space ($name), '.', $section)"/>
      <xsl:with-param name="content">
	<xsl:text>.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.\" PP
\fB\\$1\fR
.\" PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "</xsl:text>
	<xsl:value-of select="translate(refmeta/refentrytitle,'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
	<xsl:text>" </xsl:text>
	<xsl:value-of select="refmeta/manvolnum[1]"/>
	<xsl:text> "</xsl:text>
	<xsl:value-of select="refentryinfo/date"/>
	<xsl:text>" "</xsl:text>
	<xsl:value-of select="refentryinfo/productname"/>
	<xsl:text>" "</xsl:text>
	<xsl:value-of select="refentryinfo/title"/>
	<xsl:text>"
</xsl:text>
	<xsl:apply-templates/>
	<xsl:text>&#10;</xsl:text>

	<!-- Author section -->
	<xsl:choose>
	  <xsl:when test="refentryinfo//author">
	    <xsl:apply-templates select="refentryinfo" mode="authorsect"/>
	  </xsl:when>
	  <xsl:when test="/book/bookinfo//author">
	    <xsl:apply-templates select="/book/bookinfo" mode="authorsect"/>
	  </xsl:when>
	  <xsl:when test="/article/articleinfo//author">
	    <xsl:apply-templates select="/article/articleinfo" mode="authorsect"/>
	  </xsl:when>
	</xsl:choose>

      </xsl:with-param>
    </xsl:call-template>
    <!-- Now generate stub include pages for every page documented in
         this refentry (except the page itself) -->
    <xsl:for-each select="refnamediv/refname">
      <xsl:if test=". != $name">
	<xsl:call-template name="write.text.chunk">
	  <xsl:with-param name="filename"
	    select="concat(normalize-space(.), '.', $section)"/>
	  <xsl:with-param name="content" select="concat('.so man', $section, '/', $name, '.', $section, '&#10;')"/>
	</xsl:call-template>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <!-- Select this version of filename, suppress the error -->
  <xsl:template match="filename">
    <xsl:apply-templates mode="italic" select="."/>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="para">
    <xsl:text>.PP&#10;</xsl:text>
    <xsl:for-each select="node()">
      <xsl:choose>
	<xsl:when test="self::screen|self::programlisting|self::itemizedlist|self::orderedlist|self::variablelist">
	  <xsl:text>&#10;</xsl:text>
	  <xsl:apply-templates/>
	</xsl:when>
	<xsl:when test="self::text()">
	  <xsl:if test="starts-with(translate(.,'&#10;',' '), ' ') and
	                preceding-sibling::node()[name(.)!='']">
	    <xsl:text> </xsl:text>
	  </xsl:if>
	  <xsl:variable name="content">
	    <xsl:apply-templates select="."/>
	  </xsl:variable>
	  <xsl:value-of select="normalize-space($content)"/>
	  <xsl:if
	    test="translate(substring(., string-length(.), 1),'&#10;',' ')=' '
	          and following-sibling::node()[name(.)!='']">
	    <xsl:text> </xsl:text>
	  </xsl:if>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:variable name="content">
	    <xsl:apply-templates select="."/>
	  </xsl:variable>
	  <xsl:value-of select="normalize-space($content)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
    <xsl:text>&#10;</xsl:text>
  </xsl:template>

  <!-- Always print ':' , remove extra newline -->
  <xsl:template match="caution|important|note|tip|warning">
    <xsl:text>&#10;.RS&#10;.Sh "</xsl:text>
    <!-- capitalize word -->
    <xsl:value-of
      select="translate (substring (name(.), 1, 1), 'cintw', 'CINTW')" />
    <xsl:value-of select="substring (name(), 2)" />
    <xsl:text>:</xsl:text>
    <xsl:if test="title">
      <xsl:text> </xsl:text>
      <xsl:value-of select="title[1]"/>
    </xsl:if>
    <xsl:text>"&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>.RE&#10;</xsl:text>
  </xsl:template>

  <!-- ************** Modifications to manpages/lists.xsl *********** -->
  <!-- There are also caution/important/note/tip/warning entries in list! -->
  <xsl:template match="caution|important|note|tip|warning" mode="list">
    <xsl:apply-templates select="."/>
  </xsl:template> 

  <!-- Remove extra newline -->
  <xsl:template match="varlistentry|glossentry">
    <xsl:text>.TP&#10;</xsl:text>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="variablelist|glosslist" mode="list">
    <xsl:text>.RS&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>.RE&#10;</xsl:text>
  </xsl:template>

  <!-- Much simpler term entries within varlist -->
  <xsl:template match="varlistentry/term">
    <xsl:apply-templates/>
    <xsl:text>, </xsl:text>
  </xsl:template>
  <xsl:template match="varlistentry/term[position()=last()]" priority="2">
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Remove extra newlines -->
  <xsl:template match="itemizedlist|orderedlist|procedure">
    <xsl:text>.TP 3&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>.LP&#10;</xsl:text>
  </xsl:template>

  <!-- ************** Modifications to manpages/synop.xsl *********** -->
  <!-- Put repeat string after group -->
  <xsl:template match="group|arg">
    <xsl:variable name="choice" select="@choice"/>
    <xsl:variable name="rep" select="@rep"/>
    <xsl:variable name="sepchar">
      <xsl:choose>
	<xsl:when test="ancestor-or-self::*/@sepchar">
	  <xsl:value-of select="ancestor-or-self::*/@sepchar"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text> </xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="position()>1"><xsl:value-of select="$sepchar"/></xsl:if>
    <xsl:choose>
      <xsl:when test="$choice='plain'">
	<!-- do nothing -->
      </xsl:when>
      <xsl:when test="$choice='req'">
	<xsl:value-of select="$arg.choice.req.open.str"/>
      </xsl:when>
      <xsl:when test="$choice='opt'">
	<xsl:value-of select="$arg.choice.opt.open.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.choice.def.open.str"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:variable name="arg">
      <xsl:apply-templates/>
    </xsl:variable>
    <xsl:value-of select="normalize-space($arg)"/>
    <xsl:choose>
      <xsl:when test="$choice='plain'">
	<xsl:if test='arg'>
	  <xsl:value-of select="$arg.choice.plain.close.str"/>
	</xsl:if>
      </xsl:when>
      <xsl:when test="$choice='req'">
	<xsl:value-of select="$arg.choice.req.close.str"/>
      </xsl:when>
      <xsl:when test="$choice='opt'">
	<xsl:value-of select="$arg.choice.opt.close.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.choice.def.close.str"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
      <xsl:when test="$rep='repeat'">
	<xsl:value-of select="$arg.rep.repeat.str"/>
      </xsl:when>
      <xsl:when test="$rep='norepeat'">
	<xsl:value-of select="$arg.rep.norepeat.str"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$arg.rep.def.str"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="group/arg">
    <xsl:variable name="choice" select="@choice"/>
    <xsl:variable name="rep" select="@rep"/>
    <xsl:if test="position()>1"><xsl:value-of select="$arg.or.sep"/></xsl:if>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Remove extra newline -->
 <xsl:template match="cmdsynopsis">
    <xsl:text>.nf&#10;</xsl:text>
    <xsl:choose>
      <xsl:when test=".//sbr">
	<!-- The author has put explicit formatting hints in for us. -->
	<xsl:apply-templates/>
      </xsl:when>
      <xsl:otherwise>
	<!-- Try to do some smart formatting. -->
	<xsl:variable name="cmdsynopsis">
	  <xsl:apply-templates/>
	</xsl:variable>
	<xsl:variable name="cmd" select="command"/>
	<xsl:variable name="indent"
	  select="translate($cmd,$cmd,'                         ')"/>
	<xsl:text>\fB</xsl:text>
	<xsl:value-of select="$cmd"/><xsl:text>\fR </xsl:text>
	<xsl:call-template name="wrap-cmd">
	  <xsl:with-param name="indent" select="$indent"/>
	  <xsl:with-param name="text"
	    select="substring-after($cmdsynopsis,' ')"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#10;.fi&#10;</xsl:text>
  </xsl:template>

  <!-- Remove extra newline -->
  <xsl:template match="synopsis">
    <xsl:text>.nf&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>&#10;.fi&#10;</xsl:text>
  </xsl:template>

  <!-- Remove extra newline -->
  <xsl:template match="funcsynopsis">
    <xsl:text>.nf&#10;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>&#10;.fi&#10;</xsl:text>
  </xsl:template>

</xsl:stylesheet>
